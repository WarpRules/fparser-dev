/* Function Parser for C++ v3.3.2   

   Note: This file contains generated code and is thus not
   intended to be to be modified by hand. It was generated by
   fpoptimizer/bytecoderules_parser which is available in the
   development package.

   Note: You don't need to add this file to your project. It's
   enough for it to be in the same directory as fparser.cc. This
   file is internally #included by fparser.cc.
*/

#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to)
//#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to) std::cout << "Changing \"" from "\"\n    into \"" to "\"\n"
inline void FunctionParser::AddFunctionOpcode(unsigned opcode)
{
    size_t blen = data->ByteCode.size();
    size_t ilen = data->Immed.size();
    switch(opcode)
    {
    case cPow:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            if(!isEvenInteger(x*2.0))
            {
                const unsigned op_2 = data->ByteCode[blen - 2];
                switch(op_2)
                {
                case cSqr:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cSqr x[!isEvenInteger(x*2.0)] cPow", "cAbs [x*2.0] cPow");
                    data->ByteCode.resize(blen - 2);
                    data->Immed.pop_back();
                    AddFunctionOpcode(cAbs);
                    data->Immed.push_back(x*2.0);
                    data->ByteCode.push_back(cImmed);
                    AddFunctionOpcode(cPow);
                    return;
                  }
                  break;
                }
            }
            if(IsIntegerConst(x))
            {
                const unsigned op_2 = data->ByteCode[blen - 2];
                switch(op_2)
                {
                case cPow:
                  {
                    const unsigned op_3 = data->ByteCode[blen - 3];
                    switch(op_3)
                    {
                    case cImmed:
                      {
                        const double y = data->Immed[ilen - 2];
                        if(!IsIntegerConst(y))
                        {
                            FP_TRACE_BYTECODE_OPTIMIZATION("y[!IsIntegerConst(y)] cPow x[IsIntegerConst(x)] cPow", "[y*x] cPow");
                            data->Immed[ilen - 2] = y*x;
                            /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches y @ 3
                            /* data->ByteCode[blen - 2] = cPow; */ // redundant, matches cPow @ 2
                            data->ByteCode.pop_back();
                            data->Immed.pop_back();
                            return;
                        }
                        break;
                      }
                    }
                    FP_TRACE_BYTECODE_OPTIMIZATION("cPow x[IsIntegerConst(x)] cPow", "[x] cMul cPow");
                    /* data->Immed.back() = x; */ // redundant, matches x @ 1
                    data->ByteCode[blen - 2] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cMul);
                    AddFunctionOpcode(cPow);
                    return;
                  }
                  break;
                case cExp:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cExp x[IsIntegerConst(x)] cPow", "[x] cMul cExp");
                    /* data->Immed.back() = x; */ // redundant, matches x @ 1
                    data->ByteCode[blen - 2] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cMul);
                    AddFunctionOpcode(cExp);
                    return;
                  }
                  break;
                case cExp2:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cExp2 x[IsIntegerConst(x)] cPow", "[x] cMul cExp2");
                    /* data->Immed.back() = x; */ // redundant, matches x @ 1
                    data->ByteCode[blen - 2] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cMul);
                    AddFunctionOpcode(cExp2);
                    return;
                  }
                  break;
                }
            }
            if(isEvenInteger(x))
            {
                const unsigned op_2 = data->ByteCode[blen - 2];
                switch(op_2)
                {
                case cAbs:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cAbs x[isEvenInteger(x)] cPow", "[x] cPow");
                    /* data->Immed.back() = x; */ // redundant, matches x @ 1
                    data->ByteCode[blen - 2] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cPow);
                    return;
                  }
                  break;
                case cMul:
                  {
                    const unsigned op_3 = data->ByteCode[blen - 3];
                    switch(op_3)
                    {
                    case cAbs:
                      {
                        FP_TRACE_BYTECODE_OPTIMIZATION("cAbs cMul x[isEvenInteger(x)] cPow", "cMul [x] cPow");
                        data->ByteCode.resize(blen - 3);
                        data->Immed.pop_back();
                        AddFunctionOpcode(cMul);
                        data->Immed.push_back(x);
                        data->ByteCode.push_back(cImmed);
                        AddFunctionOpcode(cPow);
                        return;
                      }
                      break;
                    }
                  }
                  break;
                }
            }
            if(x==0.5)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==0.5] cPow", "cSqrt");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                AddFunctionOpcode(cSqrt);
                return;
            }
            if(x==-0.5)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==-0.5] cPow", "cRSqrt");
                data->ByteCode.back() = cRSqrt;
                data->Immed.pop_back();
                return;
            }
            if(x==-1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==-1.0] cPow", "cInv");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                AddFunctionOpcode(cInv);
                return;
            }
            if(TryCompilePowi(x))
                return;
            break;
          }
        }
      }
      break;
    case cSqrt:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cSqr:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cSqr cSqrt", "cAbs");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cAbs);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cSqrt", "[sqrt(x)]");
                data->Immed.back() = sqrt(x);
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cAbs:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cAbs", "cAbs");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cAbs);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAbs", "[fabs(x)]");
            data->Immed.back() = fabs(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsNeverNegativeValueOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsNeverNegativeValueOpcode(A)] cAbs", "A");
                /* data->ByteCode.back() = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
    case cAcos:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAcos", "[acos(x)]");
            data->Immed.back() = acos(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cAcosh:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x>=-1.0&&x<=1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=-1.0&&x<=1.0] cAcosh", "[fp_acosh(x)]");
                data->Immed.back() = fp_acosh(x);
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cAsinh:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x>=-1.0&&x<=1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=-1.0&&x<=1.0] cAsinh", "[fp_asinh(x)]");
                data->Immed.back() = fp_asinh(x);
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cAtan:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAtan", "[atan(x)]");
            data->Immed.back() = atan(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cAtanh:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAtanh", "[fp_atanh(x)]");
            data->Immed.back() = fp_atanh(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cCeil:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cCeil", "[ceil(x)]");
            data->Immed.back() = ceil(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cCeil", "A");
                /* data->ByteCode.back() = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
    case cCos:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cAcos:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAcos cCos", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cCos", "cCos");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cCos);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cCos", "[cos(x)]");
            data->Immed.back() = cos(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cCosh:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cCosh", "cCosh");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cCosh);
            return;
          }
          break;
        case cAsinh:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAsinh cCosh", "cSqr [1.0] cAdd cSqrt");
            data->ByteCode.back() = cSqr;
            data->Immed.push_back(1.0);
            data->ByteCode.push_back(cImmed);
            AddFunctionOpcode(cAdd);
            AddFunctionOpcode(cSqrt);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cCosh", "[cosh(x)]");
            data->Immed.back() = cosh(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cExp:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cLog:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLog cExp", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAdd:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = data->Immed.back();
                FP_TRACE_BYTECODE_OPTIMIZATION("x cAdd cExp", "cExp [exp(x)] cMul");
                data->ByteCode.resize(blen - 2);
                data->Immed.pop_back();
                AddFunctionOpcode(cExp);
                data->Immed.push_back(exp(x));
                data->ByteCode.push_back(cImmed);
                AddFunctionOpcode(cMul);
                return;
                break;
              }
            }
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cExp", "[exp(x)]");
            data->Immed.back() = exp(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cExp2:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cLog2:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLog2 cExp2", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAdd:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = data->Immed.back();
                FP_TRACE_BYTECODE_OPTIMIZATION("x cAdd cExp2", "cExp2 [fp_pow(2.0,x)] cMul");
                data->ByteCode.resize(blen - 2);
                data->Immed.pop_back();
                AddFunctionOpcode(cExp2);
                data->Immed.push_back(fp_pow(2.0,x));
                data->ByteCode.push_back(cImmed);
                AddFunctionOpcode(cMul);
                return;
                break;
              }
            }
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cExp2", "[fp_pow(2.0,x)]");
            data->Immed.back() = fp_pow(2.0,x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cFloor:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cFloor", "[floor(x)]");
            data->Immed.back() = floor(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cFloor", "A");
                /* data->ByteCode.back() = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
    case cInt:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cInt", "[floor(x+0.5)]");
            data->Immed.back() = floor(x+0.5);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cInt", "A");
                /* data->ByteCode.back() = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
    case cLog:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cExp:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cExp cLog", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cLog", "[log(x)]");
                data->Immed.back() = log(x);
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cLog10:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cLog10", "[log10(x)]");
                data->Immed.back() = log10(x);
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cLog2:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cExp2:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cExp2 cLog2", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cLog2", "[log(x)*1.4426950408889634074]");
                data->Immed.back() = log(x)*1.4426950408889634074;
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cSin:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cAsin:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAsin cSin", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cSin", "cSin cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cSin);
            AddFunctionOpcode(cNeg);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cSin", "[sin(x)]");
            data->Immed.back() = sin(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cSinh:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cSinh", "cSinh cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cSinh);
            AddFunctionOpcode(cNeg);
            return;
          }
          break;
        case cAcosh:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAcosh cSinh", "cSqr [-1.0] cAdd cSqrt");
            data->ByteCode.back() = cSqr;
            data->Immed.push_back(-1.0);
            data->ByteCode.push_back(cImmed);
            AddFunctionOpcode(cAdd);
            AddFunctionOpcode(cSqrt);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cSinh", "[sinh(x)]");
            data->Immed.back() = sinh(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cTan:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cAtan:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAtan cTan", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAtan2:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAtan2 cTan", "cDiv");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cDiv);
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cTan", "cTan cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cTan);
            AddFunctionOpcode(cNeg);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cTan", "[tan(x)]");
            data->Immed.back() = tan(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cTanh:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cTanh", "cTanh cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cTanh);
            AddFunctionOpcode(cNeg);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cTanh", "[tanh(x)]");
            data->Immed.back() = tanh(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cTrunc:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cTrunc", "[trunc(x)]");
            data->Immed.back() = trunc(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cTrunc", "A");
                /* data->ByteCode.back() = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
    case cDeg:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cDeg", "[RadiansToDegrees(x)]");
            data->Immed.back() = RadiansToDegrees(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cRad:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cRad", "[DegreesToRadians(x)]");
            data->Immed.back() = DegreesToRadians(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cNeg:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cMul:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = data->Immed.back();
                FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cNeg", "[-x] cMul");
                data->Immed.back() = -x;
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches x @ 2
                /* data->ByteCode.back() = cMul; */ // redundant, matches cMul @ 1
                return;
                break;
              }
            }
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cNeg", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cFloor:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cFloor cNeg", "cNeg cCeil");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNeg);
            AddFunctionOpcode(cCeil);
            return;
          }
          break;
        case cCeil:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCeil cNeg", "cNeg cFloor");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNeg);
            AddFunctionOpcode(cFloor);
            return;
          }
          break;
        case cSin:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = data->Immed.back();
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cSin cNeg", "[-x] cMul cSin");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches x @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    /* data->ByteCode.back() = cSin; */ // redundant, matches cSin @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cSinh:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = data->Immed.back();
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cSinh cNeg", "[-x] cMul cSinh");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches x @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    /* data->ByteCode.back() = cSinh; */ // redundant, matches cSinh @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cTan:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = data->Immed.back();
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cTan cNeg", "[-x] cMul cTan");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches x @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    /* data->ByteCode.back() = cTan; */ // redundant, matches cTan @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cTanh:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = data->Immed.back();
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cTanh cNeg", "[-x] cMul cTanh");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches x @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    /* data->ByteCode.back() = cTanh; */ // redundant, matches cTanh @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cNeg", "[-x]");
            data->Immed.back() = -x;
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
    case cInv:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cInv:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cInv cInv", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cPow:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cPow cInv", "cNeg cPow");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNeg);
            AddFunctionOpcode(cPow);
            return;
          }
          break;
        case cSin:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cSin cInv", "cCsc");
            data->ByteCode.back() = cCsc;
            return;
          }
          break;
        case cCos:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCos cInv", "cSec");
            data->ByteCode.back() = cSec;
            return;
          }
          break;
        case cTan:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cTan cInv", "cCot");
            data->ByteCode.back() = cCot;
            return;
          }
          break;
        case cCsc:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCsc cInv", "cSin");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cSin);
            return;
          }
          break;
        case cSec:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cSec cInv", "cCos");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cCos);
            return;
          }
          break;
        case cCot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCot cInv", "cTan");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cTan);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            if(x!=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x!=0.0] cInv", "[1.0/x]");
                data->Immed.back() = 1.0/x;
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
    case cMul:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cInv:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cInv cMul", "cDiv");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cDiv);
            return;
          }
          break;
        case cPow:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = data->Immed.back();
                if(x<0)
                {
                    FP_TRACE_BYTECODE_OPTIMIZATION("x[x<0] cPow cMul", "[-x] cPow cDiv");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches x @ 2
                    /* data->ByteCode.back() = cPow; */ // redundant, matches cPow @ 1
                    AddFunctionOpcode(cDiv);
                    return;
                }
                break;
              }
            }
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cNeg:
              {
                FP_TRACE_BYTECODE_OPTIMIZATION("cNeg x cMul", "[-x] cMul");
                data->Immed.back() = -x;
                data->ByteCode[blen - 2] = cImmed;
                data->ByteCode.pop_back();
                AddFunctionOpcode(cMul);
                return;
              }
              break;
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = data->Immed[ilen - 2];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cMul x cMul", "[y*x] cMul");
                    data->Immed[ilen - 2] = y*x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches y @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    data->ByteCode.pop_back();
                    data->Immed.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cImmed:
              {
                const double y = data->Immed[ilen - 2];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cMul", "[x*y]");
                data->Immed[ilen - 2] = x*y;
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches y @ 2
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
                break;
              }
            }
            if(x==1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==1.0] cMul", "");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
            }
            if(x==-1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==-1.0] cMul", "cNeg");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                AddFunctionOpcode(cNeg);
                return;
            }
            break;
          }
        }
      }
      break;
    case cDiv:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cInv:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cInv cDiv", "cMul");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cMul);
            return;
          }
          break;
        case cExp:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = data->Immed.back();
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cExp cDiv", "[-x] cMul cExp cMul");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches x @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    /* data->ByteCode.back() = cExp; */ // redundant, matches cExp @ 1
                    AddFunctionOpcode(cMul);
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cExp2:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = data->Immed.back();
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cExp2 cDiv", "[-x] cMul cExp2 cMul");
                    data->Immed.back() = -x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches x @ 3
                    /* data->ByteCode[blen - 2] = cMul; */ // redundant, matches cMul @ 2
                    /* data->ByteCode.back() = cExp2; */ // redundant, matches cExp2 @ 1
                    AddFunctionOpcode(cMul);
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cNeg:
              {
                FP_TRACE_BYTECODE_OPTIMIZATION("cNeg x cDiv", "[-x] cDiv");
                data->Immed.back() = -x;
                data->ByteCode[blen - 2] = cImmed;
                data->ByteCode.pop_back();
                AddFunctionOpcode(cDiv);
                return;
              }
              break;
            }
            if(x==1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==1.0] cDiv", "");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
            }
            if(x!=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x!=0.0] cDiv", "[1.0/x] cMul");
                data->Immed.back() = 1.0/x;
                /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
                AddFunctionOpcode(cMul);
                return;
            }
            break;
          }
        }
      }
      break;
    case cAdd:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cAdd", "cSub");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cSub);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cAdd:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = data->Immed[ilen - 2];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cAdd x cAdd", "[y+x] cAdd");
                    data->Immed[ilen - 2] = y+x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches y @ 3
                    /* data->ByteCode[blen - 2] = cAdd; */ // redundant, matches cAdd @ 2
                    data->ByteCode.pop_back();
                    data->Immed.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cSub:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = data->Immed[ilen - 2];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cSub x cAdd", "[y-x] cSub");
                    data->Immed[ilen - 2] = y-x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches y @ 3
                    /* data->ByteCode[blen - 2] = cSub; */ // redundant, matches cSub @ 2
                    data->ByteCode.pop_back();
                    data->Immed.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cImmed:
              {
                const double y = data->Immed[ilen - 2];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cAdd", "[y+x]");
                data->Immed[ilen - 2] = y+x;
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches y @ 2
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
                break;
              }
            }
            if(x==0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==0.0] cAdd", "");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
            }
            break;
          }
        }
      }
      break;
    case cSub:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cSub", "cAdd");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cAdd);
            return;
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cSub:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = data->Immed[ilen - 2];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cSub x cSub", "[x+y] cSub");
                    data->Immed[ilen - 2] = x+y;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches y @ 3
                    /* data->ByteCode[blen - 2] = cSub; */ // redundant, matches cSub @ 2
                    data->ByteCode.pop_back();
                    data->Immed.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cAdd:
              {
                const unsigned op_3 = data->ByteCode[blen - 3];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = data->Immed[ilen - 2];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cAdd x cSub", "[y-x] cAdd");
                    data->Immed[ilen - 2] = y-x;
                    /* data->ByteCode[blen - 3] = cImmed; */ // redundant, matches y @ 3
                    /* data->ByteCode[blen - 2] = cAdd; */ // redundant, matches cAdd @ 2
                    data->ByteCode.pop_back();
                    data->Immed.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cImmed:
              {
                const double y = data->Immed[ilen - 2];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cSub", "[y-x]");
                data->Immed[ilen - 2] = y-x;
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches y @ 2
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
                break;
              }
            }
            if(x==0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==0.0] cSub", "");
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
            }
            break;
          }
        }
      }
      break;
    case cMin:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = data->Immed[ilen - 2];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cMin", "[Min(x,y)]");
                data->Immed[ilen - 2] = Min(x,y);
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches y @ 2
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
    case cMax:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = data->Immed[ilen - 2];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cMax", "[Max(x,y)]");
                data->Immed[ilen - 2] = Max(x,y);
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches y @ 2
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
    case cAtan2:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cImmed:
          {
            const double x = data->Immed.back();
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = data->Immed[ilen - 2];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cAtan2", "[atan2(y,x)]");
                data->Immed[ilen - 2] = atan2(y,x);
                /* data->ByteCode[blen - 2] = cImmed; */ // redundant, matches y @ 2
                data->ByteCode.pop_back();
                data->Immed.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
    case cNot:
      {
        const unsigned op_1 = data->ByteCode.back();
        switch(op_1)
        {
        case cLess:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLess cNot", "cGreaterOrEq");
            data->ByteCode.back() = cGreaterOrEq;
            return;
          }
          break;
        case cLessOrEq:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLessOrEq cNot", "cGreater");
            data->ByteCode.back() = cGreater;
            return;
          }
          break;
        case cGreater:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cGreater cNot", "cLessOrEq");
            data->ByteCode.back() = cLessOrEq;
            return;
          }
          break;
        case cGreaterOrEq:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cGreaterOrEq cNot", "cLess");
            data->ByteCode.back() = cLess;
            return;
          }
          break;
        case cEqual:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cEqual cNot", "cNEqual");
            data->ByteCode.back() = cNEqual;
            return;
          }
          break;
        case cNEqual:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNEqual cNot", "cEqual");
            data->ByteCode.back() = cEqual;
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cNot", "cNot");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNot);
            return;
          }
          break;
        case cAbs:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAbs cNot", "cNot");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNot);
            return;
          }
          break;
        case cNot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNot cNot", "cNotNot");
            data->ByteCode.back() = cNotNot;
            return;
          }
          break;
        case cNotNot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNotNot cNot", "cNot");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNot);
            return;
          }
          break;
        case cAbsNotNot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAbsNotNot cNot", "cAbsNot");
            data->ByteCode.back() = cAbsNot;
            return;
          }
          break;
        case cAbsNot:
          {
            const unsigned op_2 = data->ByteCode[blen - 2];
            switch(op_2)
            {
            case cImmed: break;
            default:
                const unsigned A = op_2;
                if(IsLogicalOpcode(A))
                {
                    FP_TRACE_BYTECODE_OPTIMIZATION("A[IsLogicalOpcode(A)] cAbsNot cNot", "A");
                    /* data->ByteCode[blen - 2] = A; */ // redundant, matches A @ 2
                    data->ByteCode.pop_back();
                    return;
                }
                FP_TRACE_BYTECODE_OPTIMIZATION("A cAbsNot cNot", "A cAbsNotNot");
                /* data->ByteCode[blen - 2] = A; */ // redundant, matches A @ 2
                data->ByteCode.back() = cAbsNotNot;
                return;
            }
          }
          break;
        case cImmed:
          {
            const double x = data->Immed.back();
            FP_TRACE_BYTECODE_OPTIMIZATION("x cNot", "[!truthValue(x)]");
            data->Immed.back() = !truthValue(x);
            /* data->ByteCode.back() = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsNeverNegativeValueOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsNeverNegativeValueOpcode(A)] cNot", "A cAbsNot");
                /* data->ByteCode.back() = A; */ // redundant, matches A @ 1
                data->ByteCode.push_back(cAbsNot);
                return;
            }
        }
      }
      break;
    }
    data->ByteCode.push_back(opcode);
}
