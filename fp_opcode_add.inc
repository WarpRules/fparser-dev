/* Function Parser for C++ v3.3.2

   Note: This file contains generated code and is thus not
   intended to be to be modified by hand. It was generated by
   fpoptimizer/bytecoderules_parser which is available in the
   development package.

   Note: You don't need to add this file to your project. It's
   enough for it to be in the same directory as fparser.cc. This
   file is internally #included by fparser.cc.
*/

#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to)
//#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to) std::cout << "Changing \"" from "\"\n    into \"" to "\"\n"
inline void FunctionParser::AddFunctionOpcode(unsigned opcode)
{
    unsigned* ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
    double* ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    switch(opcode)
    {
    TailCall_cPow:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cPow_Simple:
    case cPow:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(!isEvenInteger(x*2.0))
            {
                const unsigned op_2 = ByteCodePtr[-1];
                switch(op_2)
                {
                case cSqr:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cSqr x[!isEvenInteger(x*2.0)] cPow", "cAbs [x*2.0] cPow");
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cAbs);
                    data->Immed.push_back(x*2.0);
                    data->ByteCode.push_back(cImmed);
                    /* opcode = cPow; */ // redundant, matches cPow @ 0
                    goto TailCall_cPow;
                    return;
                  }
                  break;
                }
            }
            if(IsIntegerConst(x))
            {
                const unsigned op_2 = ByteCodePtr[-1];
                switch(op_2)
                {
                case cPow:
                  {
                    const unsigned op_3 = ByteCodePtr[-2];
                    switch(op_3)
                    {
                    case cImmed:
                      {
                        const double y = ImmedPtr[-1];
                        if(!IsIntegerConst(y))
                        {
                            FP_TRACE_BYTECODE_OPTIMIZATION("y[!IsIntegerConst(y)] cPow x[IsIntegerConst(x)] cPow", "[y*x] cPow");
                            ImmedPtr[-1] = y*x;
                            /* ByteCodePtr[-2] = cImmed; */ // redundant, matches y @ 3
                            /* ByteCodePtr[-1] = cPow; */ // redundant, matches cPow @ 2
                            data->Immed.pop_back();
                            data->ByteCode.pop_back();
                            return;
                        }
                        break;
                      }
                    }
                    FP_TRACE_BYTECODE_OPTIMIZATION("cPow x[IsIntegerConst(x)] cPow", "[x] cMul cPow");
                    /* ImmedPtr[0] = x; */ // redundant, matches x @ 1
                    ByteCodePtr[-1] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cMul);
                    /* opcode = cPow; */ // redundant, matches cPow @ 0
                    goto TailCall_cPow;
                    return;
                  }
                  break;
                case cExp:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cExp x[IsIntegerConst(x)] cPow", "[x] cMul cExp");
                    /* ImmedPtr[0] = x; */ // redundant, matches x @ 1
                    ByteCodePtr[-1] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cMul);
                    opcode = cExp;
                    goto TailCall_cExp;
                    return;
                  }
                  break;
                case cExp2:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cExp2 x[IsIntegerConst(x)] cPow", "[x] cMul cExp2");
                    /* ImmedPtr[0] = x; */ // redundant, matches x @ 1
                    ByteCodePtr[-1] = cImmed;
                    data->ByteCode.pop_back();
                    AddFunctionOpcode(cMul);
                    opcode = cExp2;
                    goto TailCall_cExp2;
                    return;
                  }
                  break;
                }
            }
            if(isEvenInteger(x))
            {
                const unsigned op_2 = ByteCodePtr[-1];
                switch(op_2)
                {
                case cAbs:
                  {
                    FP_TRACE_BYTECODE_OPTIMIZATION("cAbs x[isEvenInteger(x)] cPow", "[x] cPow");
                    /* ImmedPtr[0] = x; */ // redundant, matches x @ 1
                    ByteCodePtr[-1] = cImmed;
                    ByteCodePtr -= 1;
                    data->ByteCode.pop_back();
                    /* opcode = cPow; */ // redundant, matches cPow @ 0
                    goto TailCall_cPow_Simple;
                    return;
                  }
                  break;
                case cMul:
                  {
                    const unsigned op_3 = ByteCodePtr[-2];
                    switch(op_3)
                    {
                    case cAbs:
                      {
                        FP_TRACE_BYTECODE_OPTIMIZATION("cAbs cMul x[isEvenInteger(x)] cPow", "cMul [x] cPow");
                        data->Immed.pop_back();
                        data->ByteCode.pop_back();
                        data->ByteCode.pop_back();
                        data->ByteCode.pop_back();
                        AddFunctionOpcode(cMul);
                        data->Immed.push_back(x);
                        data->ByteCode.push_back(cImmed);
                        /* opcode = cPow; */ // redundant, matches cPow @ 0
                        goto TailCall_cPow;
                        return;
                      }
                      break;
                    }
                  }
                  break;
                }
            }
            if(x==0.5)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==0.5] cPow", "cSqrt");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                opcode = cSqrt;
                goto TailCall_cSqrt;
                return;
            }
            if(x==-0.5)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==-0.5] cPow", "cRSqrt");
                ByteCodePtr[0] = cRSqrt;
                data->Immed.pop_back();
                return;
            }
            if(x==-1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==-1.0] cPow", "cInv");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                opcode = cInv;
                goto TailCall_cInv;
                return;
            }
            if(TryCompilePowi(x))
                return;
            break;
          }
        }
      }
      break;
      goto TailCall_cPow; goto TailCall_cPow_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cSqrt:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cSqrt_Simple:
    case cSqrt:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cSqr:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cSqr cSqrt", "cAbs");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cAbs;
            goto TailCall_cAbs_Simple;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cSqrt", "[sqrt(x)]");
                ImmedPtr[0] = sqrt(x);
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cSqrt; goto TailCall_cSqrt_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAbs:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAbs_Simple:
    case cAbs:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cAbs", "cAbs");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cAbs; */ // redundant, matches cAbs @ 0
            goto TailCall_cAbs_Simple;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAbs", "[fabs(x)]");
            ImmedPtr[0] = fabs(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsNeverNegativeValueOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsNeverNegativeValueOpcode(A)] cAbs", "A");
                /* ByteCodePtr[0] = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
      goto TailCall_cAbs; goto TailCall_cAbs_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAcos:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAcos_Simple:
    case cAcos:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAcos", "[acos(x)]");
            ImmedPtr[0] = acos(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cAcos; goto TailCall_cAcos_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAcosh:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAcosh_Simple:
    case cAcosh:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x>=-1.0&&x<=1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=-1.0&&x<=1.0] cAcosh", "[fp_acosh(x)]");
                ImmedPtr[0] = fp_acosh(x);
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cAcosh; goto TailCall_cAcosh_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAsinh:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAsinh_Simple:
    case cAsinh:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x>=-1.0&&x<=1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=-1.0&&x<=1.0] cAsinh", "[fp_asinh(x)]");
                ImmedPtr[0] = fp_asinh(x);
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cAsinh; goto TailCall_cAsinh_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAtan:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAtan_Simple:
    case cAtan:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAtan", "[atan(x)]");
            ImmedPtr[0] = atan(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cAtan; goto TailCall_cAtan_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAtanh:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAtanh_Simple:
    case cAtanh:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cAtanh", "[fp_atanh(x)]");
            ImmedPtr[0] = fp_atanh(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cAtanh; goto TailCall_cAtanh_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cCeil:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cCeil_Simple:
    case cCeil:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cCeil", "[ceil(x)]");
            ImmedPtr[0] = ceil(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cCeil", "A");
                /* ByteCodePtr[0] = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
      goto TailCall_cCeil; goto TailCall_cCeil_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cCos:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cCos_Simple:
    case cCos:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cAcos:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAcos cCos", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAbs:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAbs cCos", "cCos");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cCos; */ // redundant, matches cCos @ 0
            goto TailCall_cCos_Simple;
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cCos", "cCos");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cCos; */ // redundant, matches cCos @ 0
            goto TailCall_cCos_Simple;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cCos", "[cos(x)]");
            ImmedPtr[0] = cos(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cCos; goto TailCall_cCos_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cCosh:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cCosh_Simple:
    case cCosh:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cAbs:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAbs cCosh", "cCosh");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cCosh; */ // redundant, matches cCosh @ 0
            goto TailCall_cCosh_Simple;
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cCosh", "cCosh");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cCosh; */ // redundant, matches cCosh @ 0
            goto TailCall_cCosh_Simple;
            return;
          }
          break;
        case cAsinh:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAsinh cCosh", "cSqr [1.0] cAdd cSqrt");
            ByteCodePtr[0] = cSqr;
            data->Immed.push_back(1.0);
            data->ByteCode.push_back(cImmed);
            AddFunctionOpcode(cAdd);
            opcode = cSqrt;
            goto TailCall_cSqrt;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cCosh", "[cosh(x)]");
            ImmedPtr[0] = cosh(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cCosh; goto TailCall_cCosh_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cExp:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cExp_Simple:
    case cExp:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cLog:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLog cExp", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAdd:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = ImmedPtr[0];
                FP_TRACE_BYTECODE_OPTIMIZATION("x cAdd cExp", "cExp [exp(x)] cMul");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                data->ByteCode.pop_back();
                AddFunctionOpcode(cExp);
                data->Immed.push_back(exp(x));
                data->ByteCode.push_back(cImmed);
                opcode = cMul;
                goto TailCall_cMul;
                return;
                break;
              }
            }
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cExp", "[exp(x)]");
            ImmedPtr[0] = exp(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cExp; goto TailCall_cExp_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cExp2:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cExp2_Simple:
    case cExp2:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cLog2:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLog2 cExp2", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAdd:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = ImmedPtr[0];
                FP_TRACE_BYTECODE_OPTIMIZATION("x cAdd cExp2", "cExp2 [fp_pow(2.0,x)] cMul");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                data->ByteCode.pop_back();
                AddFunctionOpcode(cExp2);
                data->Immed.push_back(fp_pow(2.0,x));
                data->ByteCode.push_back(cImmed);
                opcode = cMul;
                goto TailCall_cMul;
                return;
                break;
              }
            }
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cExp2", "[fp_pow(2.0,x)]");
            ImmedPtr[0] = fp_pow(2.0,x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cExp2; goto TailCall_cExp2_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cFloor:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cFloor_Simple:
    case cFloor:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cFloor", "[floor(x)]");
            ImmedPtr[0] = floor(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cFloor", "A");
                /* ByteCodePtr[0] = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
      goto TailCall_cFloor; goto TailCall_cFloor_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cInt:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cInt_Simple:
    case cInt:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cInt", "[floor(x+0.5)]");
            ImmedPtr[0] = floor(x+0.5);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cInt", "A");
                /* ByteCodePtr[0] = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
      goto TailCall_cInt; goto TailCall_cInt_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cLog:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cLog_Simple:
    case cLog:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cExp:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cExp cLog", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cLog", "[log(x)]");
                ImmedPtr[0] = log(x);
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cLog; goto TailCall_cLog_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cLog10:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cLog10_Simple:
    case cLog10:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cLog10", "[log10(x)]");
                ImmedPtr[0] = log10(x);
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cLog10; goto TailCall_cLog10_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cLog2:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cLog2_Simple:
    case cLog2:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cExp2:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cExp2 cLog2", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x>=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x>=0.0] cLog2", "[log(x)*1.4426950408889634074]");
                ImmedPtr[0] = log(x)*1.4426950408889634074;
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cLog2; goto TailCall_cLog2_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cSin:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cSin_Simple:
    case cSin:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cAsin:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAsin cSin", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cSin", "cSin cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cSin);
            opcode = cNeg;
            goto TailCall_cNeg;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cSin", "[sin(x)]");
            ImmedPtr[0] = sin(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cSin; goto TailCall_cSin_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cSinh:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cSinh_Simple:
    case cSinh:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cSinh", "cSinh cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cSinh);
            opcode = cNeg;
            goto TailCall_cNeg;
            return;
          }
          break;
        case cAcosh:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAcosh cSinh", "cSqr [-1.0] cAdd cSqrt");
            ByteCodePtr[0] = cSqr;
            data->Immed.push_back(-1.0);
            data->ByteCode.push_back(cImmed);
            AddFunctionOpcode(cAdd);
            opcode = cSqrt;
            goto TailCall_cSqrt;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cSinh", "[sinh(x)]");
            ImmedPtr[0] = sinh(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cSinh; goto TailCall_cSinh_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cTan:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cTan_Simple:
    case cTan:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cAtan:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAtan cTan", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cAtan2:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAtan2 cTan", "cDiv");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cDiv;
            goto TailCall_cDiv_Simple;
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cTan", "cTan cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cTan);
            opcode = cNeg;
            goto TailCall_cNeg;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cTan", "[tan(x)]");
            ImmedPtr[0] = tan(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cTan; goto TailCall_cTan_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cTanh:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cTanh_Simple:
    case cTanh:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cTanh", "cTanh cNeg");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cTanh);
            opcode = cNeg;
            goto TailCall_cNeg;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cTanh", "[tanh(x)]");
            ImmedPtr[0] = tanh(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cTanh; goto TailCall_cTanh_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cTrunc:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cTrunc_Simple:
    case cTrunc:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cTrunc", "[trunc(x)]");
            ImmedPtr[0] = trunc(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsAlwaysIntegerOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsAlwaysIntegerOpcode(A)] cTrunc", "A");
                /* ByteCodePtr[0] = A; */ // redundant, matches A @ 1
                return;
            }
        }
      }
      break;
      goto TailCall_cTrunc; goto TailCall_cTrunc_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cDeg:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cDeg_Simple:
    case cDeg:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cDeg", "[RadiansToDegrees(x)]");
            ImmedPtr[0] = RadiansToDegrees(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cDeg; goto TailCall_cDeg_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cRad:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cRad_Simple:
    case cRad:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cRad", "[DegreesToRadians(x)]");
            ImmedPtr[0] = DegreesToRadians(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cRad; goto TailCall_cRad_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cNeg:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cNeg_Simple:
    case cNeg:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cMul:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = ImmedPtr[0];
                FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cNeg", "[-x] cMul");
                ImmedPtr[0] = -x;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches x @ 2
                /* ByteCodePtr[0] = cMul; */ // redundant, matches cMul @ 1
                return;
                break;
              }
            }
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cNeg", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cFloor:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cFloor cNeg", "cNeg cCeil");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNeg);
            opcode = cCeil;
            goto TailCall_cCeil;
            return;
          }
          break;
        case cCeil:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCeil cNeg", "cNeg cFloor");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNeg);
            opcode = cFloor;
            goto TailCall_cFloor;
            return;
          }
          break;
        case cSin:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = ImmedPtr[0];
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cSin cNeg", "[-x] cMul cSin");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches x @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    /* ByteCodePtr[0] = cSin; */ // redundant, matches cSin @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cSinh:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = ImmedPtr[0];
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cSinh cNeg", "[-x] cMul cSinh");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches x @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    /* ByteCodePtr[0] = cSinh; */ // redundant, matches cSinh @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cTan:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = ImmedPtr[0];
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cTan cNeg", "[-x] cMul cTan");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches x @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    /* ByteCodePtr[0] = cTan; */ // redundant, matches cTan @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cTanh:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = ImmedPtr[0];
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cTanh cNeg", "[-x] cMul cTanh");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches x @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    /* ByteCodePtr[0] = cTanh; */ // redundant, matches cTanh @ 1
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cNeg", "[-x]");
            ImmedPtr[0] = -x;
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        }
      }
      break;
      goto TailCall_cNeg; goto TailCall_cNeg_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cInv:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cInv_Simple:
    case cInv:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cInv:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cInv cInv", "");
            data->ByteCode.pop_back();
            return;
          }
          break;
        case cPow:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cPow cInv", "cNeg cPow");
            data->ByteCode.pop_back();
            AddFunctionOpcode(cNeg);
            opcode = cPow;
            goto TailCall_cPow;
            return;
          }
          break;
        case cSin:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cSin cInv", "cCsc");
            ByteCodePtr[0] = cCsc;
            return;
          }
          break;
        case cCos:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCos cInv", "cSec");
            ByteCodePtr[0] = cSec;
            return;
          }
          break;
        case cTan:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cTan cInv", "cCot");
            ByteCodePtr[0] = cCot;
            return;
          }
          break;
        case cCsc:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCsc cInv", "cSin");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cSin;
            goto TailCall_cSin_Simple;
            return;
          }
          break;
        case cSec:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cSec cInv", "cCos");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cCos;
            goto TailCall_cCos_Simple;
            return;
          }
          break;
        case cCot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cCot cInv", "cTan");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cTan;
            goto TailCall_cTan_Simple;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x!=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x!=0.0] cInv", "[1.0/x]");
                ImmedPtr[0] = 1.0/x;
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cInv; goto TailCall_cInv_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cMul:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cMul_Simple:
    case cMul:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cInv:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cInv cMul", "cDiv");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cDiv;
            goto TailCall_cDiv_Simple;
            return;
          }
          break;
        case cPow:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double x = ImmedPtr[0];
                if(x<0)
                {
                    FP_TRACE_BYTECODE_OPTIMIZATION("x[x<0] cPow cMul", "[-x] cPow cDiv");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-1] = cImmed; */ // redundant, matches x @ 2
                    /* ByteCodePtr[0] = cPow; */ // redundant, matches cPow @ 1
                    opcode = cDiv;
                    goto TailCall_cDiv_Simple;
                    return;
                }
                break;
              }
            }
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cNeg:
              {
                FP_TRACE_BYTECODE_OPTIMIZATION("cNeg x cMul", "[-x] cMul");
                ImmedPtr[0] = -x;
                ByteCodePtr[-1] = cImmed;
                ByteCodePtr -= 1;
                data->ByteCode.pop_back();
                /* opcode = cMul; */ // redundant, matches cMul @ 0
                goto TailCall_cMul_Simple;
                return;
              }
              break;
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = ImmedPtr[-1];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cMul x cMul", "[y*x] cMul");
                    ImmedPtr[-1] = y*x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches y @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cMul", "[x*y]");
                ImmedPtr[-1] = x*y;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            if(x==1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==1.0] cMul", "");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
            }
            if(x==-1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==-1.0] cMul", "cNeg");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                opcode = cNeg;
                goto TailCall_cNeg;
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cMul; goto TailCall_cMul_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cDiv:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cDiv_Simple:
    case cDiv:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cInv:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cInv cDiv", "cMul");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cMul;
            goto TailCall_cMul_Simple;
            return;
          }
          break;
        case cExp:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = ImmedPtr[0];
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cExp cDiv", "[-x] cMul cExp cMul");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches x @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    /* ByteCodePtr[0] = cExp; */ // redundant, matches cExp @ 1
                    opcode = cMul;
                    goto TailCall_cMul_Simple;
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cExp2:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cMul:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double x = ImmedPtr[0];
                    FP_TRACE_BYTECODE_OPTIMIZATION("x cMul cExp2 cDiv", "[-x] cMul cExp2 cMul");
                    ImmedPtr[0] = -x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches x @ 3
                    /* ByteCodePtr[-1] = cMul; */ // redundant, matches cMul @ 2
                    /* ByteCodePtr[0] = cExp2; */ // redundant, matches cExp2 @ 1
                    opcode = cMul;
                    goto TailCall_cMul_Simple;
                    return;
                    break;
                  }
                }
              }
              break;
            }
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cNeg:
              {
                FP_TRACE_BYTECODE_OPTIMIZATION("cNeg x cDiv", "[-x] cDiv");
                ImmedPtr[0] = -x;
                ByteCodePtr[-1] = cImmed;
                ByteCodePtr -= 1;
                data->ByteCode.pop_back();
                /* opcode = cDiv; */ // redundant, matches cDiv @ 0
                goto TailCall_cDiv_Simple;
                return;
              }
              break;
            }
            if(x==1.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==1.0] cDiv", "");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
            }
            if(x!=0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x!=0.0] cDiv", "[1.0/x] cMul");
                ImmedPtr[0] = 1.0/x;
                /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
                opcode = cMul;
                goto TailCall_cMul_Simple;
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cDiv; goto TailCall_cDiv_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cMod:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cMod_Simple:
    case cMod:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            if(x!=0.0)
            {
                const unsigned op_2 = ByteCodePtr[-1];
                switch(op_2)
                {
                case cImmed:
                  {
                    const double y = ImmedPtr[-1];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y x[x!=0.0] cMod", "[fmod(y,x)]");
                    ImmedPtr[-1] = fmod(y,x);
                    /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    return;
                    break;
                  }
                }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cMod; goto TailCall_cMod_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAdd:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAdd_Simple:
    case cAdd:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cAdd", "cSub");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cSub;
            goto TailCall_cSub_Simple;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cAdd:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = ImmedPtr[-1];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cAdd x cAdd", "[y+x] cAdd");
                    ImmedPtr[-1] = y+x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches y @ 3
                    /* ByteCodePtr[-1] = cAdd; */ // redundant, matches cAdd @ 2
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cSub:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = ImmedPtr[-1];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cSub x cAdd", "[y-x] cSub");
                    ImmedPtr[-1] = y-x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches y @ 3
                    /* ByteCodePtr[-1] = cSub; */ // redundant, matches cSub @ 2
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cAdd", "[y+x]");
                ImmedPtr[-1] = y+x;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            if(x==0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==0.0] cAdd", "");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cAdd; goto TailCall_cAdd_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cSub:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cSub_Simple:
    case cSub:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cSub", "cAdd");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cAdd;
            goto TailCall_cAdd_Simple;
            return;
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cSub:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = ImmedPtr[-1];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cSub x cSub", "[x+y] cSub");
                    ImmedPtr[-1] = x+y;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches y @ 3
                    /* ByteCodePtr[-1] = cSub; */ // redundant, matches cSub @ 2
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cAdd:
              {
                const unsigned op_3 = ByteCodePtr[-2];
                switch(op_3)
                {
                case cImmed:
                  {
                    const double y = ImmedPtr[-1];
                    FP_TRACE_BYTECODE_OPTIMIZATION("y cAdd x cSub", "[y-x] cAdd");
                    ImmedPtr[-1] = y-x;
                    /* ByteCodePtr[-2] = cImmed; */ // redundant, matches y @ 3
                    /* ByteCodePtr[-1] = cAdd; */ // redundant, matches cAdd @ 2
                    data->Immed.pop_back();
                    data->ByteCode.pop_back();
                    return;
                    break;
                  }
                }
              }
              break;
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cSub", "[y-x]");
                ImmedPtr[-1] = y-x;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            if(x==0.0)
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("x[x==0.0] cSub", "");
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cSub; goto TailCall_cSub_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cMin:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cMin_Simple:
    case cMin:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cMin", "[Min(x,y)]");
                ImmedPtr[-1] = Min(x,y);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cMin; goto TailCall_cMin_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cMax:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cMax_Simple:
    case cMax:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cMax", "[Max(x,y)]");
                ImmedPtr[-1] = Max(x,y);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cMax; goto TailCall_cMax_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAtan2:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAtan2_Simple:
    case cAtan2:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cAtan2", "[atan2(y,x)]");
                ImmedPtr[-1] = atan2(y,x);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cAtan2; goto TailCall_cAtan2_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cNot:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cNot_Simple:
    case cNot:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cLess:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLess cNot", "cGreaterOrEq");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cGreaterOrEq;
            goto TailCall_cGreaterOrEq_Simple;
            return;
          }
          break;
        case cLessOrEq:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cLessOrEq cNot", "cGreater");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cGreater;
            goto TailCall_cGreater_Simple;
            return;
          }
          break;
        case cGreater:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cGreater cNot", "cLessOrEq");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cLessOrEq;
            goto TailCall_cLessOrEq_Simple;
            return;
          }
          break;
        case cGreaterOrEq:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cGreaterOrEq cNot", "cLess");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cLess;
            goto TailCall_cLess_Simple;
            return;
          }
          break;
        case cEqual:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cEqual cNot", "cNEqual");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cNEqual;
            goto TailCall_cNEqual_Simple;
            return;
          }
          break;
        case cNEqual:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNEqual cNot", "cEqual");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            opcode = cEqual;
            goto TailCall_cEqual_Simple;
            return;
          }
          break;
        case cNeg:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNeg cNot", "cNot");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cNot; */ // redundant, matches cNot @ 0
            goto TailCall_cNot_Simple;
            return;
          }
          break;
        case cAbs:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAbs cNot", "cNot");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cNot; */ // redundant, matches cNot @ 0
            goto TailCall_cNot_Simple;
            return;
          }
          break;
        case cNot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNot cNot", "cNotNot");
            ByteCodePtr[0] = cNotNot;
            return;
          }
          break;
        case cNotNot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cNotNot cNot", "cNot");
            ByteCodePtr -= 1;
            data->ByteCode.pop_back();
            /* opcode = cNot; */ // redundant, matches cNot @ 0
            goto TailCall_cNot_Simple;
            return;
          }
          break;
        case cAbsNotNot:
          {
            FP_TRACE_BYTECODE_OPTIMIZATION("cAbsNotNot cNot", "cAbsNot");
            ByteCodePtr[0] = cAbsNot;
            return;
          }
          break;
        case cAbsNot:
          {
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed: break;
            default:
                const unsigned A = op_2;
                if(IsLogicalOpcode(A))
                {
                    FP_TRACE_BYTECODE_OPTIMIZATION("A[IsLogicalOpcode(A)] cAbsNot cNot", "A");
                    /* ByteCodePtr[-1] = A; */ // redundant, matches A @ 2
                    data->ByteCode.pop_back();
                    return;
                }
                FP_TRACE_BYTECODE_OPTIMIZATION("A cAbsNot cNot", "A cAbsNotNot");
                /* ByteCodePtr[-1] = A; */ // redundant, matches A @ 2
                ByteCodePtr[0] = cAbsNotNot;
                return;
            }
          }
          break;
        case cImmed:
          {
            const double x = ImmedPtr[0];
            FP_TRACE_BYTECODE_OPTIMIZATION("x cNot", "[!truthValue(x)]");
            ImmedPtr[0] = !truthValue(x);
            /* ByteCodePtr[0] = cImmed; */ // redundant, matches x @ 1
            return;
            break;
          }
        default:
            const unsigned A = op_1;
            if(IsNeverNegativeValueOpcode(A))
            {
                FP_TRACE_BYTECODE_OPTIMIZATION("A[IsNeverNegativeValueOpcode(A)] cNot", "A cAbsNot");
                /* ByteCodePtr[0] = A; */ // redundant, matches A @ 1
                data->ByteCode.push_back(cAbsNot);
                return;
            }
        }
      }
      break;
      goto TailCall_cNot; goto TailCall_cNot_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cLess:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cLess_Simple:
    case cLess:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cLess", "[y <  (x-EpsilonOrZero)]");
                ImmedPtr[-1] = y <  (x-EpsilonOrZero);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cLess; goto TailCall_cLess_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cLessOrEq:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cLessOrEq_Simple:
    case cLessOrEq:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cLessOrEq", "[y <= (x+EpsilonOrZero)]");
                ImmedPtr[-1] = y <= (x+EpsilonOrZero);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cLessOrEq; goto TailCall_cLessOrEq_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cGreater:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cGreater_Simple:
    case cGreater:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cGreater", "[(y-EpsilonOrZero) >  x]");
                ImmedPtr[-1] = (y-EpsilonOrZero) >  x;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cGreater; goto TailCall_cGreater_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cGreaterOrEq:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cGreaterOrEq_Simple:
    case cGreaterOrEq:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cGreaterOrEq", "[(y+EpsilonOrZero) >= x]");
                ImmedPtr[-1] = (y+EpsilonOrZero) >= x;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cGreaterOrEq; goto TailCall_cGreaterOrEq_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cEqual:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cEqual_Simple:
    case cEqual:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cEqual", "[fabs(y-x) <= EpsilonOrZero]");
                ImmedPtr[-1] = fabs(y-x) <= EpsilonOrZero;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cEqual; goto TailCall_cEqual_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cNEqual:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cNEqual_Simple:
    case cNEqual:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cNEqual", "[fabs(y-x) >= EpsilonOrZero]");
                ImmedPtr[-1] = fabs(y-x) >= EpsilonOrZero;
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cNEqual; goto TailCall_cNEqual_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cAnd:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cAnd_Simple:
    case cAnd:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cAnd", "[truthValue(x)&&truthValue(y)]");
                ImmedPtr[-1] = truthValue(x)&&truthValue(y);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cAnd; goto TailCall_cAnd_Simple; /* Dummy gotos to inhibit gcc warnings */
    TailCall_cOr:
      ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;
      ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;
    TailCall_cOr_Simple:
    case cOr:
      {
        const unsigned op_1 = ByteCodePtr[0];
        switch(op_1)
        {
        case cImmed:
          {
            const double x = ImmedPtr[0];
            const unsigned op_2 = ByteCodePtr[-1];
            switch(op_2)
            {
            case cImmed:
              {
                const double y = ImmedPtr[-1];
                FP_TRACE_BYTECODE_OPTIMIZATION("y x cOr", "[truthValue(x)||truthValue(y)]");
                ImmedPtr[-1] = truthValue(x)||truthValue(y);
                /* ByteCodePtr[-1] = cImmed; */ // redundant, matches y @ 2
                data->Immed.pop_back();
                data->ByteCode.pop_back();
                return;
                break;
              }
            }
            break;
          }
        }
      }
      break;
      goto TailCall_cOr; goto TailCall_cOr_Simple; /* Dummy gotos to inhibit gcc warnings */
    }
    data->ByteCode.push_back(opcode);
}
