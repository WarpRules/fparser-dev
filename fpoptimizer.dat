# This datafile documents all the possible optimizations that the optimizer can/should do
#
# It is the plan that in the future, this should be autogenerated into code
#
#

[ENTRY]
# These optimizations are done only once, before the intermediate conversions.
# This process converts some optimized opcodes into primitives, so as to
# make the intermediate optimizations simpler to write. In the final stage,
# the optimized opcodes are reconstructed where available.

# x / y = x * 1/y
cDiv [x y] -> cMul x ~y

# x - y = x + -y
cSub [x y] -> cAdd x ~y

# 1/x   = <implied> * ~x
cInv x   -> cMul ~x

# -x    = <implied> + -x
cNeg x   -> cAdd ~x

# deg(x) = x * CONSTANT_DR
cDeg x   -> cMul x CONSTANT_DR

# rad(x) = x * CONSTANT_RD
cRad x   -> cMul x CONSTANT_RD

# cot(x) = <implied> * ~tan(x)
cCot x   -> cMul ~(cTan x)

# csc(x) = <implied> * ~sin(x)
cCsc x   -> cMul ~(cSin x)

# sec(x) = <implied> * ~cos(x)
cSec x   -> cMul ~(cCos x)

# sqrt(x) = x^0.5
cSqrt x   -> cPow x 0.5

# exp(x) = CONSTANT_E^x
cExp x    -> cPow CONSTANT_E x

# log10(x) = log(x) * CONSTANT_L10I
cLog10 x  -> cMul (cLog x) CONSTANT_L10I

# log2(x) = log(x) * CONSTANT_L2I
cLog2 x  -> cMul (cLog x) CONSTANT_L2I


[INTERMEDIATE]

#### Remove redundant components:

# In a pluslist, having x and -x gets both deleted
cPlus x ~x -> cPlus
# In a mullist,  having x and 1/x gets both deleted
cMul  x ~x -> cMul
# In a pluslist, immeds having the value 0 are deleted
cPlus 0    -> cPlus
# In a mullist, immeds having the value 1 are deleted
cMul  1    -> cMul
# In a mullist, an occurrence of the immed 0 deletes all items
cMul  0 *  -> cMul
# In a min-list, two identical components are reduced into one
cMin x x   -> cMin x
# In a max-list, two identical components are reduced into one
cMax x x   -> cMax x


#### Simplify empty groups:

# An empty min-list gets replaced with immed NaN
cMin  []   -> NaN
# An empty max-list gets replaced with immed NaN
cMax  []   -> NaN
# An empty pluslist gets replaced with immed 0
cPlus  []   -> 0
# An empty mullist gets replaced with immed 1
cMul  []   -> 1

# A single-token min-list gets replaced with that single token
cMin [x]   -> x
# A single-token max-list gets replaced with that single token
cMin [x]   -> x
# A single-token pluslist gets replaced with that single token (note: NOT when negated)
cPlus [x]   -> x
# A single-token maxlist gets replaced with that single token (note: NOT when inverted)
cMax [x]   -> x
# If a pow has an exponent of 1, replace the pow with the base value
cPow [x 1] -> x


#### Assimilate children:

# If a pluslist contains another pluslist, assimilate the child (but xor the signs)
cAdd (cAdd [*])   -> cAdd *
cAdd ~(cAdd [*])  -> cAdd ~*

# If a mullist contains another mullist, assimilate the child (but xor the signs)
cMul (cMul [*])   -> cMul *
cMul ~(cMul [*])  -> cMul ~*

# If a min-list contains another min-list, assimilate the child
cMin (cMin [*])   -> cMin *

# If a max-list contains another max-list, assimilate the child
cMax (cMax [*])   -> cMax *


#### Linear combining

# If a mul-list contains the same element four or more times,
# replace the element with a pow with an integer exponent
# (note: inversions are treated as a negative exponent)
# e.g. ...*x*x*x*x -> ...*x^4
# NOTE: Observe this too: x^3 * x -> x^4
# NOTE: The reverse may also be useful, if x is a primitive
TODO: Develop some kind of markup here

# If an add-list contains the same element four or more times,
# replace the element with a mul with an integer factor
# (note: negations are treated as a negative factor)
# e.g. ...+x+x+x+x -> ...+x*4
# NOTE: Observe this too: x*3 + x -> x*4
# NOTE: The reverse may also be useful, if x is a primitive
TODO: Develop some kind of markup here


#### Remote double negations/inversions

# If an addlist contains a negated mul and that mul-list contains a factor,
# un-negate the mul-list and negate the factor in the mul-list.
cAdd ~(cMul #) -> cAdd (cMul -#)

# If a mullist contains an inverted pow and the exponent is an immed,
# un-negate the pow and negate the immed.
cMul ~(cPow [x #]) -> cMul (cPow [x -#])

# (x^y)^z        -> x^(y*z)
cPow [ (cPow[x y]) z ]  -> cPow x (cMul y z)

# (x^y) *  (x^z) -> x^(y+z)
TODO: Develop some kind of markup here


#### Constant folding:

# If a pluslist contains two or more immeds, replace those immeds
# with a single non-negated immed that has the sum of those original
# immeds (paying attention to the polarity of those immeds)
TODO: Develop some kind of markup here

# If a mullist contains two or more immeds, replace those immeds
# with a single non-inverted immed that has the product of those original
# immeds (paying attention to the polarity of those immeds)
TODO: Develop some kind of markup here

# If a min-list contains two or more immeds, replace those immeds
# with a single immed that is the minimum of the original immeds
TODO: Develop some kind of markup here

# If a max-list contains two or more immeds, replace those immeds
# with a single immed that is the maximum of the original immeds
TODO: Develop some kind of markup here

# TODO: Add function call optimization with constant params
# such as sin(immed)->newimmed, sqrt(immed)->newimmed etc.


#### Logarithm optimizations
# pow(x,y)/log(y) = x
TODO: Develop some kind of markup here
cMul (cPow [x y]) ~(cLog y)  -> x

# CONSTANT_E^log(x) = x
cPow [CONSTANT_E (cLog x)] -> x

# CONSTANT_E^(log(x)*y) = x^y
cPow [CONSTANT_E (cLog x)] -> x

# z^(log(x)/log(z)*y) = x^y
cPow [z (cMul (cLog x) y ~cLog(z))] = cPow x y

# log(x^z) = z * log(x)
cLog (cPow [x z]) -> cMul z (cLog x)

# log(x) + log(y) + log(z) = log(x*y*z)
TODO: Develop some kind of markup here

# log(x * CONSTANT_E^y) = log(x) + y
cLog (cMul x (cPow [CONSTANT_E y])) -> cAdd (cLog x) y

# log(x * z^y) / log(z) = log(x) / log(z) + y
cMul (cLog (cMul x (cPow [z y]))) ~(cLog z)  -> cAdd (cMul (cLog x) ~(cLog z)) y


#### Self-defeating function calls:
# sin(asin(x)) = x
TODO: Develop some kind of markup here

# cos(acos(x)) = x
TODO: Develop some kind of markup here

# tan(atan(x)) = x
TODO: Develop some kind of markup here

# Note: asin(sin(x)) must not be converted, because
# even though asin(sin(1.1)) = 1.1, asin(sin(1500)) != 1500.


[FINAL]
# These optimizations are done only once, after the intermediate conversions.
# This process generates optimized opcodes that are not expected to be found
# in the intermediate stage.

# x * CONSTANT_DR -> cDeg(x)
# x * ~CONSTANT_RD -> cDeg(x)
TODO: Develop some kind of markup here

# x * CONSTANT_RD -> cRad(x)
# x * ~CONSTANT_DR -> cRad(x)
TODO: Develop some kind of markup here

# x^0.5 -> sqrt(x)
TODO: Develop some kind of markup here

# log(x) * CONSTANT_L10I -> log10(x)
TODO: Develop some kind of markup here

# log(x) * CONSTANT_L2I -> log2(x)
TODO: Develop some kind of markup here

# pow(CONSTANT_E, x) -> exp(x)
TODO: Develop some kind of markup here

# In a mul-list, ~sin(x) -> csc(x)
TODO: Develop some kind of markup here

# In a mul-list, ~cos(x) -> sec(x)
TODO: Develop some kind of markup here

# In a mul-list, ~tan(x) -> cot(x)
TODO: Develop some kind of markup here
