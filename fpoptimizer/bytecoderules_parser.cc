#include <ctype.h>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <assert.h>
#include <map>
#include <set>

#include "crc32.hh"

//#define USE_CONTINUATIONS

namespace
{
    const char kOutputCommentBlock[] =
        "/* Function Parser for C++ v4.0.2   \n\n"
        "   Note: This file contains generated code and is thus not\n"
        "   intended to be to be modified by hand. It was generated by\n"
        "   fpoptimizer/bytecoderules_parser which is available in the\n"
        "   development package.\n\n"
        "   Note: You don't need to add this file to your project. It's\n"
        "   enough for it to be in the same directory as fparser.cc. This\n"
        "   file is internally #included by fparser.cc.\n"
        "*/\n";

    struct Operation
    {
        enum { Opcode, Immed } type;
        std::string result;
    };
    struct Match
    {
        enum { FixedOpcode, Immed, AnyOpcode } type;
        std::string name;         // opcode name such as cInt, or holder name such as x or X
        std::string condition;    // condition that applies when Immed or AnyOpcode

        bool operator==(const Match& b) const
        {
            return type==b.type
                && name==b.name
                && condition==b.condition;
        }

        std::vector<Operation> operations;
        bool has_operations;
    };
    struct Node
    {
        Match opcode;
        std::vector<Node*> predecessors;
    };

    Node global_head;
    std::set<std::string> PossiblyUnusedLabelList;

    std::string Indent(size_t n)
    {
        return std::string(n, ' ');
    }

    std::string Bexpr(size_t pos)
    {
        if(pos == 0) return "opcode";
        std::ostringstream tmp;
        tmp << "ByteCodePtr[" << -int(pos-1) << "]";
        return tmp.str();
    }

    std::string Iexpr(size_t pos)
    {
        std::ostringstream tmp;
        tmp << "ImmedPtr[" << -int(pos) << "]";
        return tmp.str();
    }

    std::string BexprName(size_t pos)
    {
        if(pos == 0) return "opcode";
        std::ostringstream tmp;
        tmp << "op_" << pos;
        return tmp.str();
    }

    bool HasHandlingFor(const std::string& opcode)
    {
        if(!(opcode[0] == 'c' && isupper(opcode[1])))
            return true;
        for(size_t b=0; b<global_head.predecessors.size(); ++b)
            if(global_head.predecessors[b]->opcode.type == Match::FixedOpcode
            && global_head.predecessors[b]->opcode.name == opcode)
                return true;
        return false;
    }

    struct LineSeqs
    {
        void OutChain(std::ostream& out,
                      const std::vector<std::string>& chain,
                      size_t indent)
        {
            std::string codehash, prevlabel;
            for(size_t a=chain.size(); a-- > 0; )
            {
                codehash += chain[a];
                std::string label = GenLabel(codehash);
                Chains::iterator i = code.lower_bound(label);
                if(i != code.end() && i->first == label)
                {
                    std::string got_chain;
                    for(Chains::iterator j = i; j != code.end(); )
                    {
                        got_chain.insert(0, j->second.code);
                        if(j->second.nextlabel.empty()) break;
                        j = code.find(j->second.nextlabel);
                    }
                    /*
                    std::cerr << "expected: <" << codehash << ">\n"
                                 "got:      <" << got_chain << ">\n",
                    */
                    assert(got_chain == codehash);

                    // nothing to do
                    i->second.n_uses += 1;
                    if(!prevlabel.empty())
                        code.find(prevlabel)->second.n_uses -= 1;
                }
                else
                {
                    ChainItem item;
                    item.code         = chain[a];
                    item.nextlabel    = prevlabel;
                    item.n_uses       = 1;
                    code.insert(i, std::make_pair(label, item));
                }
                prevlabel = label;
            }
            if(!prevlabel.empty())
            {
                heads.push_back(prevlabel);
                out << Indent(indent) << "goto " << ChangeLabel(prevlabel) << ";\n";
            }
        }
        void Flush(std::ostream& out)
        {
            std::set<std::string> done;
            std::vector<std::string> remain;

            for(size_t a=0; a<heads.size(); ++a)
            {
                if(done.find(heads[a]) != done.end())
                    continue;

                size_t mini = 0;
                remain.push_back(heads[a]);
                while(!remain.empty())
                {
                    Chains::const_iterator i = code.find(remain.back());
                    remain.pop_back();

                    const ChainItem& item = i->second;
                    done.insert(i->first);

                    if(item.n_uses > mini)
                    {
                        std::string l = ChangeLabel(i->first);
                        out << l << ": ";
                    }
                    else
                        out << std::string(5, ' ');
                    //out << " /*" << item.n_uses << "*/ ";
                    out << item.code;
                    if(!item.nextlabel.empty())
                    {
                        if(done.find(item.nextlabel) != done.end())
                        {
                            std::string l = ChangeLabel(item.nextlabel);
                            out << " goto " << l << ';';
                        }
                        else
                            remain.push_back(item.nextlabel);
                    }
                    else if(item.code.compare(0,5,"goto ") != false)
                        out << " return;";
                    out << "\n";

                    mini = 1;
                }
            }
        }
    private:
        std::string GenLabel(unsigned crc, unsigned len)
        {
            static const char table[] =
                /*"0123456789"*/
                /*"ABCDEFGHIJKLMNOPQRSTUVWXYZ"*/
                "abcdefghijklmn"
                /*"opqrstuvwxyz_"*/;
            char result[16] = {0};
            int o=15;
            while(true)
            {
                result[--o] = table[crc % (sizeof(table)-1)];
                crc /= (sizeof(table)-1);
                if(crc == 0 && (16-o) > 2) break;
            }
            result[--o] = 'L';
            std::string result2(result+o);
            result2.resize(len,' ');
            return result2;
        }
        std::string GenLabel(const std::string& code)
        {
            return GenLabel(crc32::calc((const unsigned char*)&code[0], code.size()), 20);
        }
        std::string ChangeLabel(const std::string& orig)
        {
            std::map<std::string, unsigned>::iterator
                j = label_trans.lower_bound(orig);
            if(j != label_trans.end() && j->first == orig)
                return GenLabel(j->second, 3u);
            size_t lno = label_trans.size();
            label_trans.insert(j, std::make_pair(orig, lno));
            return GenLabel(unsigned(lno), 3u);
        }
    private:
        struct ChainItem
        {
            std::string code;
            std::string nextlabel;
            unsigned n_uses;
        };
        typedef std::map<std::string/*label*/, ChainItem> Chains;
        std::vector<std::string> heads;
        std::map<std::string, unsigned> label_trans;
        Chains code;
    } CodeSeq;

    struct OutCode;
    struct OutLine
    {
        OutLine(OutCode& o) : out(o) { }
        template<typename T>
        OutLine& operator<< (const T& b) { buf << b; return *this; }
        ~OutLine();
    private:
        OutCode& out;
        std::ostringstream buf;
    };
    struct OutCode
    {
        OutCode(std::ostream& o, size_t i)
            : out(o),
              indent(i) { }
        ~OutCode()
        {
            for(size_t a=0; a<seq.size(); )
            {
                if(seq[a][0] == '/' && seq[a][1] == '*')
                {
                    out << Indent(indent) << seq[a] << "\n";
                    seq.erase(seq.begin()+a);
                }
                else ++a;
            }
            #ifdef USE_CONTINUATIONS
            if(!seq.empty() && seq.back().compare(0,9,"goto Tail")==false)
            {
                size_t skip = 0;
                for(size_t a=0; a<seq.size(); ++a)
                {
                    if(seq[a].compare(0,8,"opcode =") == false)
                    {
                        std::string opcode_assign = seq[a];
                        seq.erase(seq.begin()+a);
                        seq.insert(seq.begin(), opcode_assign);
                        skip = 1;
                        break;
                    }
                }
                if(seq.size() > skip+1)
                {
                    //const std::string tail_label = seq.back().substr(5);
                    //const std::string tail_opcode = tail_label.substr(9, tail_label.size()-10);
                    //CodeSeq.AddContinuation(tail_label, tail_opcode);
                    //std::string continuation_line =
                    //    "/""* Will tailcall " + tail_opcode + " *""/";
                    //seq.insert(seq.begin()+skip, continuation_line);
                    seq.back() = "goto PickContinuation;";
                }
            }
            #endif
            CodeSeq.OutChain(out, seq, indent);
            if(seq.empty())
                out << Indent(indent) << "return;\n";
        }
        void Flush()
        {
            for(size_t a=0; a<seq.size(); ++a)
                out << Indent(indent) << seq[a] << "\n";
            seq.clear();
        }
        bool HasOperations() const { return !seq.empty(); }
    private:
        friend class OutLine;
        void DidLine(const std::string& line) { seq.push_back(line); }
        std::ostream& out;
        std::vector<std::string> seq;
        size_t indent;
    };
    OutLine::~OutLine()
    {
        out.DidLine(buf.str());
    }

    struct Synther
    {
        Synther(OutCode& o, size_t i)
            : Out(o),
              know_bytecode_offset(true),
              know_immed_offset(true),
              indent(i)
        {
        }

        /* Reset is called before an operation that requires
         * that the vector's size() reflects the state shown
         * in the Ptr variable.
         * It is assumed that what follows is an instruction
         * that may reallocate the vector and invalidate pointers.
         */

        void ResetImmed(int offset = 0)
        {
        #if 0
            if(know_immed_offset)
            {
                OutLine(Out)  << "data->Immed.resize( " << (1-offset) << " + ImmedPtr - &data->Immed[0] );";
            }
            know_immed_offset = false;
        #else
            know_immed_offset = false;
            PopImmedBy(offset);
        #endif
        }

        void ResetByteCode(int offset = 0)
        {
        #if 0
            if(know_bytecode_offset)
            {
                OutLine(Out)  << "data->ByteCode.resize( " << (1-offset) << " + ByteCodePtr - &data->ByteCode[0] );";
            }
            know_bytecode_offset = false;
        #else
            know_bytecode_offset = false;
            PopByteCodeBy(offset);
        #endif
        }

        void ResetBoth(int b_offset, int i_offset)
        {
            ResetImmed(i_offset);
            ResetByteCode(b_offset);
        }

        void PopByteCodeBy(int n)
        {
        #if 0
            if(know_bytecode_offset)
                OutLine(Out)  << "ByteCodePtr -= " << n << ";";
            else
                for(; n > 0; --n)
                    OutLine(Out)  << "data->ByteCode.pop_back();";
        #else
            if(know_bytecode_offset)
                OutLine(Out)  << "ByteCodePtr -= " << n << ";";
            for(; n > 0; --n)
                OutLine(Out)  << "data->ByteCode.pop_back();";
        #endif
        }

        void PopImmedBy(int n)
        {
        #if 0
            if(know_immed_offset)
                OutLine(Out)  << "ImmedPtr -= " << n << ";";
            else
                for(; n > 0; --n)
                    OutLine(Out)  << "data->Immed.pop_back();";
        #else
            if(know_immed_offset)
                OutLine(Out)  << "ImmedPtr -= " << n << ";";
            for(; n > 0; --n)
                OutLine(Out)  << "data->Immed.pop_back();";
        #endif
        }

        bool KnowOffsets() const
        {
            return know_bytecode_offset && know_immed_offset;
        }

    private:
        OutCode& Out;
        bool know_bytecode_offset, know_immed_offset;
        size_t indent;
    };

    bool SynthOperations(
        size_t indent, std::ostream& outstream,
        const std::vector<Match>& so_far,
        std::vector<Operation> operations,
        size_t b_used,
        size_t i_used)
    {
        outstream
            << Indent(indent)
            << "FP_TRACE_BYTECODE_OPTIMIZATION(\"";
        for(size_t a=so_far.size(); a-- > 0; )
        {
            if(a+1 != so_far.size()) outstream << ' ';
            outstream << so_far[a].name;
            if(!so_far[a].condition.empty())
                outstream << '[' << so_far[a].condition << ']';
        }
        outstream << "\", \"";
        for(size_t a=0; a<operations.size(); ++a)
        {
            if(a > 0) outstream << ' ';
            if(operations[a].type == Operation::Immed) outstream << '[';
            outstream << operations[a].result;
            if(operations[a].type == Operation::Immed) outstream << ']';
        }
        outstream << "\");\n";

        if(!operations.empty() && operations[0].result == "DO_POWI")
        {
            outstream
                << Indent(indent) << "if(TryCompilePowi(" << so_far.back().name << "))\n"
                << Indent(indent) << "  return;\n";
            return false;
        }
        if(!operations.empty() && operations[0].result == "DO_MAYBE_SQR")
        {
            /* Catch the common case of "x x cMul" -> "x cSqr" */
            outstream
                << Indent(indent) << "if(" << so_far[1].name << " >= VarBegin)\n"
                << Indent(indent) << "{\n"
                << Indent(indent) << "  if(" << so_far[1].name << " == " << Bexpr(2) << ")\n"
                << Indent(indent) << "    { " << Bexpr(1) << " = cSqr; return; }\n"
            /* Catch the common case of x cMul x cMul -> x cSqr cMul */
                << Indent(indent) << "  if(" << Bexpr(2) << " == cMul && " << so_far[1].name << " == " << Bexpr(3) << ")\n"
                << Indent(indent) << "    { " << Bexpr(1) << " = cMul; " << Bexpr(2) << " = cSqr; return; }\n"
                << Indent(indent) << "}\n";
            return false;
        }
        if(!operations.empty() && operations[0].result == "DO_STACKPLUS1")
        {
            outstream
                << Indent(indent) << "incStackPtr();\n"
                << Indent(indent) << "--StackPtr;\n";
            operations.erase(operations.begin());
        }

        OutCode Out(outstream, indent);

        int n_b_exist  = (int)(b_used-1);
        int n_i_exist  = (int)(i_used  );

        int b_offset = n_b_exist;
        int i_offset = n_i_exist;

        Synther offset_synth(Out, indent);

        for(size_t a=0; a<operations.size(); ++a)
        {
            std::string opcode = operations[a].result;

            if(operations[a].type == Operation::Immed)
            {
                bool requires_var = false;
                for(size_t a=0; a<opcode.size(); ++a)
                    if(isalpha(opcode[a]))
                        requires_var = true;

                if(i_offset > 0)
                {
                    bool i_redundant = false;
                    const Match& m = so_far[i_offset];
                    if(m.type == Match::Immed && opcode == m.name)
                        i_redundant = true;
                    if(i_redundant)
                    {
                        requires_var = false;
                        OutLine(Out)
                            << "/* " << Iexpr(i_offset-1) << " = " << opcode << "; */"
                            << " // redundant, matches " << so_far[i_offset].name
                            << " @ " << (i_offset);
                    }
                    else
                    {
                        OutLine(Out)  << Iexpr(i_offset-1) << " = " << opcode << ";";
                    }
                }
                else
                {
                    offset_synth.ResetImmed();
                    OutLine(Out)  << "data->Immed.push_back(" << opcode << ");";
                }
                //if(requires_var) { Out.Flush(); requires_var = false; }
                --i_offset;
                opcode = "cImmed";
            }

            bool redundant = false;
            if(b_offset > 0)
            {
                const Match& m = so_far[b_offset];
                if(opcode == (m.type == Match::Immed ? "cImmed" : m.name))
                {
                    redundant = true;
                }
            }

            bool requires_var = !(opcode[0] == 'c' && isupper(opcode[1]));

            if(!redundant && HasHandlingFor(opcode))
            {
                if(a+1 == operations.size()
                && opcode[0] == 'c' && isupper(opcode[1]))
                {
                    if(b_offset > 0 && i_offset > 0)
                        offset_synth.ResetBoth(b_offset, i_offset);
                    else
                    {
                        if(b_offset > 0) offset_synth.PopByteCodeBy(b_offset);
                        if(i_offset > 0) offset_synth.PopImmedBy(i_offset);
                    }
                    if(so_far[0].type == Match::FixedOpcode
                    && so_far[0].name == operations.back().result)
                    {
                        OutLine(Out)
                            << "/* opcode = " << operations.back().result << "; */"
                            << " // redundant, matches " << so_far[0].name << " @ 0";
                    }
                    else
                    {
                        OutLine(Out)  << "opcode = " << operations.back().result << ";";
                    }

                    if(offset_synth.KnowOffsets())
                        OutLine(Out)  << "goto TailCall_" << opcode << ";";
                    else
                    {
                        OutLine(Out)  << "FP_ReDefinePointers();";
                        OutLine(Out)  << "goto TailCall_" << opcode << ";";
                        //OutLine(Out)  << "AddFunctionOpcode(opcode);";
                    }
                    PossiblyUnusedLabelList.erase("TailCall_" + opcode);
                    return true;
                }
                else
                {
                    offset_synth.ResetBoth(b_offset>0 ? b_offset : 0,
                                           i_offset>0 ? i_offset : 0);
                    OutLine(Out)  << "AddFunctionOpcode(" << opcode << ");";
                    //if(requires_var) { Out.Flush(); requires_var = false; }
                    i_offset = b_offset = 0;
                }
            }
            else
            {
                if(b_offset > 0)
                {
                    if(redundant)
                    {
                        requires_var = false;
                        OutLine(Out)
                            << "/* " << Bexpr(b_offset) << " = " << opcode << "; */"
                            << " // redundant, matches " << so_far[b_offset].name
                            << " @ " << (b_offset);
                    }
                    else
                        OutLine(Out)  << Bexpr(b_offset) << " = " << opcode << ";";
                }
                else
                {
                    offset_synth.ResetByteCode();
                    OutLine(Out)  << "data->ByteCode.push_back(" << opcode << ");";
                }
                if(requires_var) { Out.Flush(); requires_var = false; }
                --b_offset;
            }
        }
        offset_synth.ResetBoth(b_offset,i_offset);

        if(!Out.HasOperations())
            outstream << "return;\n";
        return true;
    }

    std::set<std::string> declared;

    enum { mode_children = 1, mode_operations = 2 };
    bool Generate(
        const Node& head,
        const std::vector<Match>& so_far,
        size_t indent,
        std::ostream& declarations,
        std::ostream& code,
        size_t b_used,
        size_t i_used,
        int mode = mode_children+mode_operations)
    {
        if(!head.predecessors.empty() && (mode & mode_children))
        {
            std::string last_op_name = BexprName(b_used);
            /*
            if(last_op_name != "opcode")
                code << Indent(indent) << "const unsigned " << last_op_name << " = " << Bexpr(b_used) << ";\n";
            code << Indent(indent) << "switch(" << last_op_name << ")\n";
            */
        #ifdef USE_CONTINUATIONS
            if(b_used == 0)
            {
                code << Indent(indent-2) << "PickContinuation:\n";
            }
        #endif
            code << Indent(indent) << "switch(" << Bexpr(b_used) << ")\n";
            code << Indent(indent) << "{\n";
            for(size_t a=0; a<head.predecessors.size(); ++a)
            {
                const Node& n = *head.predecessors[a];
                if(n.opcode.type == Match::FixedOpcode)
                {
                #ifndef USE_CONTINUATIONS
                    if(b_used == 0)
                    {
                        code << Indent(indent) << "TailCall_" << n.opcode.name << ":\n";
                        PossiblyUnusedLabelList.insert("TailCall_" + n.opcode.name);
                    }
                #endif
                    code << Indent(indent) << "  case " << n.opcode.name << ":\n";
                    //code << Indent(indent) << "  {\n";
                    std::vector<Match> ref(so_far);
                    ref.push_back(n.opcode);
                    bool returned = Generate(n, ref, indent+4, declarations,code, b_used+1, i_used);
                    //code << Indent(indent) << "  }\n";
                    if(!returned)
                        code << Indent(indent) << "    break;\n";
                }
            }
            bool first_immed = true;
            std::set<std::string> immed_labels;
            bool immed_returned = false;
            /*
              Round 0:  no-code, has condition,  mode_children
              Round 1:  no-code, no condition,   mode_children
              Round 2:  code, has condition,     mode_children | mode_operations
              Round 3:  code, no condition,      mode_children | mode_operations
            */
            for(int round=0; round<4; ++round)
                for(size_t a=0; a<head.predecessors.size(); ++a)
                {
                    const Node& n = *head.predecessors[a];
                    if(n.opcode.type == Match::Immed)
                    {
                        if(round < 2  && n.opcode.has_operations) continue;
                        if(round >= 2 && !n.opcode.has_operations) continue;
                        if((round & 1) != !!n.opcode.condition.empty()) continue;

                        if(first_immed)
                        {
                            code << Indent(indent) << "  case cImmed:\n";
                            first_immed = false;
                        }
                        //code << Indent(indent) << "  /* round " << round << " a = " << a << " */\n";
                        std::set<std::string>::iterator i = immed_labels.lower_bound(n.opcode.name);
                        if(i == immed_labels.end() || *i != n.opcode.name)
                        {
                            if(declared.find(n.opcode.name) == declared.end())
                            {
                                declared.insert(n.opcode.name);
                                declarations << Indent(2) << "Value_t " << n.opcode.name << ";\n";
                            }

                            code << Indent(indent) << "    " << n.opcode.name << " = " << Iexpr(i_used) << ";\n";
                            immed_labels.insert(i, n.opcode.name);
                        }
                        std::vector<Match> ref(so_far);
                        ref.push_back(n.opcode);
                        if(n.opcode.condition.empty())
                            immed_returned =
                                Generate(n, ref, indent+4, declarations,code, b_used+1, i_used+1, mode_children|(round>=2?mode_operations:0));
                        else
                        {
                            code << Indent(indent) << "    if(" << n.opcode.condition << ")\n";
                            code << Indent(indent) << "    {\n";
                            Generate(n, ref, indent+6, declarations,code, b_used+1, i_used+1, mode_children|(round>=2?mode_operations:0));
                            code << Indent(indent) << "    }\n";
                        }
                    }
                }
            if(!first_immed)
            {
                if(!immed_returned)
                    code << Indent(indent) << "    break;\n";
            }

            bool first_anyopcode = true;
            std::set<std::string> opcode_labels;
            for(int round=0; round<4; ++round)
                for(size_t a=0; a<head.predecessors.size(); ++a)
                {
                    const Node& n = *head.predecessors[a];
                    if(n.opcode.type == Match::AnyOpcode)
                    {
                        if(round < 2  && n.opcode.has_operations) continue;
                        if(round >= 2 && !n.opcode.has_operations) continue;
                        if((round & 1) != !!n.opcode.condition.empty()) continue;
                        if(first_anyopcode)
                        {
                            if(first_immed)
                            {
                                code << Indent(indent) << "  case cImmed: break;\n";
                            }
                            code << Indent(indent) << "  default:\n";
                            first_anyopcode = false;
                        }
                        //code << Indent(indent) << "  /* round " << round << " a = " << a << " */\n";
                        std::set<std::string>::iterator i = opcode_labels.lower_bound(n.opcode.name);
                        if(i == opcode_labels.end() || *i != n.opcode.name)
                        {
                            if(declared.find(n.opcode.name) == declared.end())
                            {
                                declared.insert(n.opcode.name);
                                declarations << Indent(2) << "unsigned " << n.opcode.name << ";\n";
                            }
                            //code << Indent(indent) << "    " << n.opcode.name << " = " << last_op_name << ";\n";
                            code << Indent(indent) << "    " << n.opcode.name << " = " << Bexpr(b_used) << ";\n";
                            opcode_labels.insert(i, n.opcode.name);
                        }
                        std::vector<Match> ref(so_far);
                        ref.push_back(n.opcode);
                        if(n.opcode.condition.empty())
                            Generate(n, ref, indent+4, declarations,code, b_used+1, i_used, mode_children|(round>=2?mode_operations:0));
                        else
                        {
                            code << Indent(indent) << "    if(" << n.opcode.condition << ")\n";
                            code << Indent(indent) << "    {\n";
                            Generate(n, ref, indent+6, declarations,code, b_used+1, i_used, mode_children|(round>=2?mode_operations:0));
                            code << Indent(indent) << "    }\n";
                        }
                    }
                }
            code << Indent(indent) << "}\n";
        }
        if(head.opcode.has_operations && (mode & mode_operations))
        {
            /*if(!head.predecessors.empty())
                std::cout << Indent(indent) << "/""* NOTE: POSSIBLY AMBIGIOUS *""/\n";*/
            if(SynthOperations(indent,code, so_far, head.opcode.operations, b_used, i_used))
            {
                //out << Indent(indent) << "return;\n";
                // ^ now redundant, as it is done by SynthOperations()
                return true;
            }
        }
        return false;
    }

    void Generate(std::ostream& out)
    {
        std::ostringstream code;
        std::ostream& declarations = out;
        Generate(global_head, std::vector<Match>(), 2, declarations,code, 0,0);
        out << code.str();

        { OutCode Out(out, 2);
          Synther(Out, 2).ResetBoth(0,0);
          OutLine(Out) << "data->ByteCode.push_back(opcode);";
        }
        CodeSeq.Flush(out);

        out << "return;\n";
        out << "// This list of dummy gotos is here to inhibit\n"
               "// compiler warnings on unused labels\n";
        unsigned a=0;
        for(std::set<std::string>::const_iterator
            i = PossiblyUnusedLabelList.begin();
            i != PossiblyUnusedLabelList.end();
            ++i)
        {
            out << "goto " << *i << ";";
            if(a+1 == PossiblyUnusedLabelList.size()
            || a%3 == 2) out << "\n";
            ++a;
        }
    }


    struct ParsingMode
    {
        std::set<std::string> different_preconditions;
        bool collect_preconditions;
        std::set<std::string> allowed_preconditions;
    };
    void Parse(ParsingMode& mode)
    {
        while(true)
        {
            char Buf[2048];
            if(!std::fgets(Buf, sizeof(Buf), stdin)) break;
            char* bufptr = Buf;
            while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
            if(*bufptr == '#' || *bufptr == '\r' || *bufptr == '\n') continue;

            std::string Precondition;

            if(*bufptr == 'I' && bufptr[1] == 'F' && bufptr[2] == '(')
            {
                bufptr += 3;
                size_t balance = 0;
                while(*bufptr != ')' || balance != 0)
                {
                    if(*bufptr == '\r' || *bufptr == '\n') break;
                    if(*bufptr == '(') ++balance;
                    if(*bufptr == ')') --balance;
                    Precondition += *bufptr++;
                }
                if(*bufptr == ')') ++bufptr;
                while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
            }

            if(mode.collect_preconditions)
            {
                if(!Precondition.empty())
                    mode.different_preconditions.insert(Precondition);
                continue;
            }

            if(!Precondition.empty()
            && mode.allowed_preconditions.find(Precondition)
            == mode.allowed_preconditions.end())
            {
                continue;
            }

            std::vector<Match> sequence;
            while(true)
            {
                Match m;
                m.has_operations = false;
                while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
                if(*bufptr == '-' && bufptr[1] == '>') break;
                while(isalnum(*bufptr)) m.name += *bufptr++;
                while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
                if(*bufptr == '#') break;
                if(*bufptr == '[')
                {
                    size_t balance = 0; ++bufptr;
                    while(*bufptr != ']' || balance != 0)
                    {
                        if(*bufptr == '\r' || *bufptr == '\n') break;
                        if(*bufptr == '[') ++balance;
                        if(*bufptr == ']') --balance;
                        m.condition += *bufptr++;
                    }
                    if(*bufptr == ']') ++bufptr;
                }
                if(m.name[0] == 'c' && m.name.size() > 1)
                    m.type = Match::FixedOpcode;
                else if(isupper(m.name[0]))
                    m.type = Match::AnyOpcode;
                else
                    m.type = Match::Immed;

                sequence.push_back(m);
            }

            Node* head = &global_head;
            for(size_t b=sequence.size(); b-->0; )
            {
                const Match& m = sequence[b];
                bool dup = false;
                for(size_t a=0; a< head->predecessors.size(); ++a)
                {
                    if(m == head->predecessors[a]->opcode)
                    {
                        head = head->predecessors[a];
                        dup = true;
                        break;
                    }
                }
                if(!dup)
                {
                    Node* newhead = new Node;
                    newhead->opcode = m;
                    head->predecessors.push_back(newhead);
                    head = newhead;
                }
            }

            if(*bufptr == '-' && bufptr[1] == '>')
            {
                head->opcode.has_operations = true;
                bufptr += 2;

                while(true)
                {
                    while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
                    if(*bufptr == '#' || *bufptr == '\r' || *bufptr == '\n') break;
                    Operation op;
                    if(*bufptr == '[')
                    {
                        size_t balance = 0; ++bufptr;
                        while(*bufptr != ']' || balance != 0)
                        {
                            if(*bufptr == '\r' || *bufptr == '\n') break;
                            if(*bufptr == '[') ++balance;
                            if(*bufptr == ']') --balance;
                            op.result += *bufptr++;
                        }
                        if(*bufptr == ']') ++bufptr;
                        op.type = Operation::Immed;
                    }
                    else
                    {
                        while(isalnum(*bufptr))
                            op.result += *bufptr++;
                        op.type = Operation::Opcode;
                    }
                    head->opcode.operations.push_back(op);
                }
            }
        }
    }
}

int main()
{
    ParsingMode mode;
    mode.collect_preconditions = true;
    Parse(mode);

    std::vector<std::string> different_preconditions(
        mode.different_preconditions.begin(),
        mode.different_preconditions.end() );

    size_t n_different_parsers = 1 << different_preconditions.size();

    std::ostream& out = std::cout;

    out << kOutputCommentBlock << "\n";
    out << "#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to)\n";
    out << "//#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to) std::cout << \"Changing \\\"\" from \"\\\"\\n    into \\\"\" to \"\\\"\\n\"\n";
    //out << "template<typename Value_t>\n"
    //       "inline void FunctionParserBase<Value_t>::AddFunctionOpcode(unsigned opcode)\n"
    //       "{\n";
    out <<  "  unsigned* ByteCodePtr;\n"
            "  Value_t*   ImmedPtr;\n"
#if(0) // This causes a crash when compiling with Visual Studio
            "#ifdef _GLIBCXX_DEBUG\n"
            "  /* Shut up glibc warnings */\n"
            "  #define FP_ReDefinePointers() \\\n"
            "    ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0; \\\n"
            "    ImmedPtr    = !data->Immed.empty()    ? &data->Immed[0]    + data->Immed.size()    - 1 : 0;\n"
            "#else\n"
            "  /* Trust me, I know what I am doing */\n"
            "  #define FP_ReDefinePointers() \\\n"
            "    ByteCodePtr = &data->ByteCode[data->ByteCode.size() - 1]; \\\n"
            "    ImmedPtr    = &data->Immed   [data->Immed.size()    - 1];\n"
            "#endif\n"
#else
            "  #define FP_ReDefinePointers() \\\n"
            "    ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0; \\\n"
            "    ImmedPtr    = !data->Immed.empty()    ? &data->Immed[0]    + data->Immed.size()    - 1 : 0;\n"
#endif
            "  FP_ReDefinePointers();\n";

    for(size_t n=0; n<n_different_parsers; ++n)
    {
        mode.collect_preconditions = false;
        mode.allowed_preconditions.clear();
        for(size_t b=0; b<different_preconditions.size(); ++b)
        {
            if(n & (1 << b))
                mode.allowed_preconditions.insert(different_preconditions[b]);
        }
        if(std::fseek(stdin, 0, SEEK_SET) < 0)
        {
            std::perror("fseek");
            return -1;
        }

        global_head = Node();
        PossiblyUnusedLabelList.clear();
        declared.clear();

        Parse(mode);

        if(n_different_parsers == 1)
            Generate(out);
        else
        {
            const char* sep = "#if(";
            for(size_t b=0; b<different_preconditions.size(); ++b, sep = " && ")
            {
                if(n & (1 << b))
                    out << sep << different_preconditions[b];
                else
                    out << sep << "!" << different_preconditions[b];
            }
            out << ")\n";
            Generate(out);
            out << "#endif\n";
        }
    }

    out << "#undef FP_ReDefinePointers\n";
    //out << "}\n";
    out << "#undef FP_TRACE_BYTECODE_OPTIMIZATION\n";

    return 0;
}
