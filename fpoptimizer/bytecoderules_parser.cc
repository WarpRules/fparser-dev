#include <ctype.h>
#include <cstdio>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>

namespace
{
    const char kOutputCommentBlock[] =
        "/* Function Parser for C++ v3.3.2\n\n"
        "   Note: This file contains generated code and is thus not\n"
        "   intended to be to be modified by hand. It was generated by\n"
        "   fpoptimizer/bytecoderules_parser which is available in the\n"
        "   development package.\n\n"
        "   Note: You don't need to add this file to your project. It's\n"
        "   enough for it to be in the same directory as fparser.cc. This\n"
        "   file is internally #included by fparser.cc.\n"
        "*/\n";

    struct Operation
    {
        enum { Opcode, Immed } type;
        std::string result;
    };
    struct Match
    {
        enum { FixedOpcode, Immed, AnyOpcode } type;
        std::string name;         // opcode name such as cInt, or holder name such as x or X
        std::string condition;    // condition that applies when Immed or AnyOpcode

        bool operator==(const Match& b) const
        {
            return type==b.type
                && name==b.name
                && condition==b.condition;
        }
        std::vector<Operation> operations;
        bool has_operations;
    };
    struct Node
    {
        Match opcode;
        std::vector<Node*> predecessors;
    };

    Node global_head;

    std::string Indent(size_t n)
    {
        return std::string(n, ' ');
    }

    std::string Bexpr(size_t pos)
    {
        if(pos == 0) return "opcode";
        std::ostringstream tmp;
        tmp << "ByteCodePtr[" << -int(pos-1) << "]";
        return tmp.str();
    }

    std::string Iexpr(size_t pos)
    {
        std::ostringstream tmp;
        tmp << "ImmedPtr[" << -int(pos) << "]";
        return tmp.str();
    }

    std::string BexprName(size_t pos)
    {
        if(pos == 0) return "opcode";
        std::ostringstream tmp;
        tmp << "op_" << pos;
        return tmp.str();
    }

    bool HasHandlingFor(const std::string& opcode)
    {
        if(!(opcode[0] == 'c' && isupper(opcode[1])))
            return true;
        for(size_t b=0; b<global_head.predecessors.size(); ++b)
            if(global_head.predecessors[b]->opcode.type == Match::FixedOpcode
            && global_head.predecessors[b]->opcode.name == opcode)
                return true;
        return false;
    }

    struct Synther
    {
        Synther(std::ostream& o, size_t i)
            : out(o),
              know_bytecode_offset(true),
              know_immed_offset(true),
              indent(i)
        {
        }

        /* Reset is called before an operation that requires
         * that the vector's size() reflects the state shown
         * in the Ptr variable.
         * It is assumed that what follows is an instruction
         * that may reallocate the vector and invalidate pointers.
         */

        void ResetImmed(int offset = 0)
        {
        #if 0
            if(know_immed_offset)
            {
                out << Indent(indent) << "data->Immed.resize( " << (1-offset) << " + ImmedPtr - &data->Immed[0] );\n";
            }
            know_immed_offset = false;
        #else
            know_immed_offset = false;
            PopImmedBy(offset);
        #endif
        }

        void ResetByteCode(int offset = 0)
        {
        #if 0
            if(know_bytecode_offset)
            {
                out << Indent(indent) << "data->ByteCode.resize( " << (1-offset) << " + ByteCodePtr - &data->ByteCode[0] );\n";
            }
            know_bytecode_offset = false;
        #else
            know_bytecode_offset = false;
            PopByteCodeBy(offset);
        #endif
        }

        void ResetBoth(int b_offset, int i_offset)
        {
            ResetImmed(i_offset);
            ResetByteCode(b_offset);
        }

        void PopByteCodeBy(int n)
        {
        #if 0
            if(know_bytecode_offset)
                out << Indent(indent) << "ByteCodePtr -= " << n << ";\n";
            else
                for(; n > 0; --n)
                    out << Indent(indent) << "data->ByteCode.pop_back();\n";
        #else
            if(know_bytecode_offset)
                out << Indent(indent) << "ByteCodePtr -= " << n << ";\n";
            for(; n > 0; --n)
                out << Indent(indent) << "data->ByteCode.pop_back();\n";
        #endif
        }

        void PopImmedBy(int n)
        {
        #if 0
            if(know_immed_offset)
                out << Indent(indent) << "ImmedPtr -= " << n << ";\n";
            else
                for(; n > 0; --n)
                    out << Indent(indent) << "data->Immed.pop_back();\n";
        #else
            if(know_immed_offset)
                out << Indent(indent) << "ImmedPtr -= " << n << ";\n";
            for(; n > 0; --n)
                out << Indent(indent) << "data->Immed.pop_back();\n";
        #endif
        }

        bool KnowOffsets() const
        {
            return know_bytecode_offset && know_immed_offset;
        }

    private:
        std::ostream& out;
        bool know_bytecode_offset, know_immed_offset;
        size_t indent;
    };

    bool SynthOperations(
        size_t indent, std::ostream& out,
        const std::vector<Match>& so_far,
        const std::vector<Operation>& operations,
        size_t b_used,
        size_t i_used)
    {
        if(!operations.empty() && operations[0].result == "DO_POWI")
        {
            out << Indent(indent) << "if(TryCompilePowi(" << so_far.back().name << "))\n";
            out << Indent(indent) << "    return;\n";
            return false;
        }

        int n_b_exist  = (int)(b_used-1);
        int n_i_exist  = (int)(i_used  );

        int b_offset = n_b_exist;
        int i_offset = n_i_exist;

        out << Indent(indent) << "FP_TRACE_BYTECODE_OPTIMIZATION(\"";
        for(size_t a=so_far.size(); a-- > 0; )
        {
            if(a+1 != so_far.size()) out << ' ';
            out << so_far[a].name;
            if(!so_far[a].condition.empty())
                out << '[' << so_far[a].condition << ']';
        }
        out << "\", \"";
        for(size_t a=0; a<operations.size(); ++a)
        {
            if(a > 0) out << ' ';
            if(operations[a].type == Operation::Immed) out << '[';
            out << operations[a].result;
            if(operations[a].type == Operation::Immed) out << ']';
        }
        out << "\");\n";

        Synther offset_synth(out, indent);

        for(size_t a=0; a<operations.size(); ++a)
        {
            std::string opcode = operations[a].result;
            if(operations[a].type == Operation::Immed)
            {
                if(i_offset > 0)
                {
                    bool i_redundant = false;
                    const Match& m = so_far[i_offset];
                    if(m.type == Match::Immed && opcode == m.name)
                        i_redundant = true;
                    if(i_redundant)
                    {
                        out << Indent(indent) << "/* " << Iexpr(i_offset-1) << " = " << opcode << "; */";
                        out << " // redundant, matches " << so_far[i_offset].name;
                        out << " @ " << (i_offset) << "\n";
                    }
                    else
                        out << Indent(indent) << Iexpr(i_offset-1) << " = " << opcode << ";\n";
                }
                else
                {
                    offset_synth.ResetImmed();
                    out << Indent(indent) << "data->Immed.push_back(" << opcode << ");\n";
                }
                --i_offset;
                opcode = "cImmed";
            }

            bool redundant = false;
            if(b_offset > 0)
            {
                const Match& m = so_far[b_offset];
                if(opcode == (m.type == Match::Immed ? "cImmed" : m.name))
                {
                    redundant = true;
                }
            }

            if(!redundant && HasHandlingFor(opcode))
            {
                if(a+1 == operations.size()
                && opcode[0] == 'c' && isupper(opcode[1]))
                {
                    if(b_offset > 0 && i_offset > 0)
                        offset_synth.ResetBoth(b_offset, i_offset);
                    else
                    {
                        if(b_offset > 0) offset_synth.PopByteCodeBy(b_offset);
                        if(i_offset > 0) offset_synth.PopImmedBy(i_offset);
                    }
                    if(so_far[0].type == Match::FixedOpcode
                    && so_far[0].name == opcode)
                    {
                        out << Indent(indent) << "/* opcode = " << opcode << "; */";
                        out << " // redundant, matches " << so_far[0].name << " @ 0\n";
                    }
                    else
                    {
                        out << Indent(indent) << "opcode = " << opcode << ";\n";
                    }
                    if(offset_synth.KnowOffsets())
                        out << Indent(indent) << "goto TailCall_" << opcode << "_Simple;\n";
                    else
                        out << Indent(indent) << "goto TailCall_" << opcode << ";\n";
                    return true;
                }
                else
                {
                    offset_synth.ResetBoth(b_offset>0 ? b_offset : 0,
                                           i_offset>0 ? i_offset : 0);
                    out << Indent(indent) << "AddFunctionOpcode(" << opcode << ");\n";
                    i_offset = b_offset = 0;
                }
            }
            else
            {
                if(b_offset > 0)
                {
                    if(redundant)
                    {
                        out << Indent(indent) << "/* " << Bexpr(b_offset) << " = " << opcode << "; */";
                        out << " // redundant, matches " << so_far[b_offset].name;
                        out << " @ " << (b_offset) << "\n";
                    }
                    else
                        out << Indent(indent) << Bexpr(b_offset) << " = " << opcode << ";\n";
                }
                else
                {
                    offset_synth.ResetByteCode();
                    out << Indent(indent) << "data->ByteCode.push_back(" << opcode << ");\n";
                }
                --b_offset;
            }
        }
        offset_synth.ResetBoth(b_offset,i_offset);
        return true;
    }

    enum { mode_children = 1, mode_operations = 2 };
    void Generate(
        const Node& head,
        const std::vector<Match>& so_far,
        size_t indent,
        std::ostream& out,
        size_t b_used,
        size_t i_used,
        int mode = mode_children+mode_operations)
    {
        if(!head.predecessors.empty() && (mode & mode_children))
        {
            std::string last_op_name = BexprName(b_used);
            if(last_op_name != "opcode")
                out << Indent(indent) << "const unsigned " << last_op_name << " = " << Bexpr(b_used) << ";\n";
            out << Indent(indent) << "switch(" << last_op_name << ")\n";
            out << Indent(indent) << "{\n";
            for(size_t a=0; a<head.predecessors.size(); ++a)
            {
                const Node& n = *head.predecessors[a];
                if(n.opcode.type == Match::FixedOpcode)
                {
                    if(b_used == 0)
                    {
                        out << Indent(indent) << "TailCall_" << n.opcode.name << ":\n";
                        out << Indent(indent) << "  ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;\n";
                        out << Indent(indent) << "  ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;\n";
                        out << Indent(indent) << "TailCall_" << n.opcode.name << "_Simple:\n";
                    }
                    out << Indent(indent) << "case " << n.opcode.name << ":\n";
                    out << Indent(indent) << "  {\n";
                    std::vector<Match> ref(so_far);
                    ref.push_back(n.opcode);
                    Generate(n, ref, indent+4, out, b_used+1, i_used);
                    out << Indent(indent) << "  }\n";
                    out << Indent(indent) << "  break;\n";
                    if(b_used == 0)
                    {
                        // Add dummy gotos to the labels to prevent gcc warnings
                        out << Indent(indent) << "  goto TailCall_" << n.opcode.name << "; goto TailCall_" << n.opcode.name << "_Simple; /* Dummy gotos to inhibit gcc warnings */\n";
                    }
                }
            }
            bool first_immed = true;
            std::set<std::string> immed_labels;
            for(int round=0; round<4; ++round)
                for(size_t a=0; a<head.predecessors.size(); ++a)
                {
                    const Node& n = *head.predecessors[a];
                    if(n.opcode.type == Match::Immed)
                    {
                        if(round < 2  && n.opcode.has_operations) continue;
                        if(round >= 2 && !n.opcode.has_operations) continue;
                        if((round & 1) != !!n.opcode.condition.empty()) continue;
                        if(first_immed)
                        {
                            out << Indent(indent) << "case cImmed:\n";
                            first_immed = false;
                        }
                        //out << Indent(indent) << "  /* round " << round << " a = " << a << " */\n";
                        std::set<std::string>::iterator i = immed_labels.lower_bound(n.opcode.name);
                        if(i == immed_labels.end() || *i != n.opcode.name)
                        {
                            if(immed_labels.empty())
                                out << Indent(indent) << "  {\n";
                            out << Indent(indent) << "    const double " << n.opcode.name << " = " << Iexpr(i_used) << ";\n";
                            immed_labels.insert(i, n.opcode.name);
                        }
                        std::vector<Match> ref(so_far);
                        ref.push_back(n.opcode);
                        if(n.opcode.condition.empty())
                            Generate(n, ref, indent+4, out, b_used+1, i_used+1, round>=2?mode_operations:mode_children);
                        else
                        {
                            out << Indent(indent) << "    if(" << n.opcode.condition << ")\n";
                            out << Indent(indent) << "    {\n";
                            Generate(n, ref, indent+8, out, b_used+1, i_used+1, round>=2?mode_operations:mode_children);
                            out << Indent(indent) << "    }\n";
                        }
                    }
                }
            if(!first_immed)
            {
                out << Indent(indent) << "    break;\n";
                if(!immed_labels.empty())
                    out << Indent(indent) << "  }\n";
            }

            bool first_anyopcode = true;
            std::set<std::string> opcode_labels;
            for(int round=0; round<4; ++round)
                for(size_t a=0; a<head.predecessors.size(); ++a)
                {
                    const Node& n = *head.predecessors[a];
                    if(n.opcode.type == Match::AnyOpcode)
                    {
                        if(round < 2  && n.opcode.has_operations) continue;
                        if(round >= 2 && !n.opcode.has_operations) continue;
                        if((round & 1) != !!n.opcode.condition.empty()) continue;
                        if(first_anyopcode)
                        {
                            if(first_immed)
                            {
                                out << Indent(indent) << "case cImmed: break;\n";
                            }
                            out << Indent(indent) << "default:\n";
                            first_anyopcode = false;
                        }
                        //out << Indent(indent) << "  /* round " << round << " a = " << a << " */\n";
                        std::set<std::string>::iterator i = opcode_labels.lower_bound(n.opcode.name);
                        if(i == opcode_labels.end() || *i != n.opcode.name)
                        {
                            out << Indent(indent) << "    const unsigned " << n.opcode.name << " = " << last_op_name << ";\n";
                            opcode_labels.insert(i, n.opcode.name);
                        }
                        std::vector<Match> ref(so_far);
                        ref.push_back(n.opcode);
                        if(n.opcode.condition.empty())
                            Generate(n, ref, indent+4, out, b_used+1, i_used, round>=2?mode_operations:mode_children);
                        else
                        {
                            out << Indent(indent) << "    if(" << n.opcode.condition << ")\n";
                            out << Indent(indent) << "    {\n";
                            Generate(n, ref, indent+8, out, b_used+1, i_used, round>=2?mode_operations:mode_children);
                            out << Indent(indent) << "    }\n";
                        }
                    }
                }
            out << Indent(indent) << "}\n";
        }
        if(head.opcode.has_operations && (mode & mode_operations))
        {
            /*if(!head.predecessors.empty())
                std::cout << Indent(indent) << "/""* NOTE: POSSIBLY AMBIGIOUS *""/\n";*/
            if(SynthOperations(indent,out, so_far, head.opcode.operations, b_used, i_used))
                out << Indent(indent) << "return;\n";
        }
    }

    void Generate(std::ostream& out)
    {
        out << kOutputCommentBlock << "\n";
        out << "#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to)\n";
        out << "//#define FP_TRACE_BYTECODE_OPTIMIZATION(from,to) std::cout << \"Changing \\\"\" from \"\\\"\\n    into \\\"\" to \"\\\"\\n\"\n";
        out << "inline void FunctionParser::AddFunctionOpcode(unsigned opcode)\n"
               "{\n"
                "    unsigned* ByteCodePtr = !data->ByteCode.empty() ? &data->ByteCode[0] + data->ByteCode.size() - 1 : 0;\n"
                "    double* ImmedPtr = !data->Immed.empty() ? &data->Immed[0] + data->Immed.size() - 1 : 0;\n";
        Generate(global_head, std::vector<Match>(), 4, out, 0,0);

        Synther(out,4).ResetBoth(0,0);

        out << "    data->ByteCode.push_back(opcode);\n"
               "}\n";
    }

    void Parse()
    {
        for(;;)
        {
            char Buf[2048];
            if(!std::fgets(Buf, sizeof(Buf), stdin)) break;
            char* bufptr = Buf;
            while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
            if(*bufptr == '#' || *bufptr == '\r' || *bufptr == '\n') continue;

            std::vector<Match> sequence;
            for(;;)
            {
                Match m;
                m.has_operations = false;
                while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
                if(*bufptr == '-' && bufptr[1] == '>') break;
                while(isalnum(*bufptr)) m.name += *bufptr++;
                while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
                if(*bufptr == '[')
                {
                    size_t balance = 0; ++bufptr;
                    while(*bufptr != ']' || balance != 0)
                    {
                        if(*bufptr == '\r' || *bufptr == '\n') break;
                        if(*bufptr == '[') ++balance;
                        if(*bufptr == ']') --balance;
                        m.condition += *bufptr++;
                    }
                    if(*bufptr == ']') ++bufptr;
                }
                if(m.name[0] == 'c' && m.name.size() > 1)
                    m.type = Match::FixedOpcode;
                else if(isupper(m.name[0]))
                    m.type = Match::AnyOpcode;
                else
                    m.type = Match::Immed;

                sequence.push_back(m);
            }

            Node* head = &global_head;
            for(size_t b=sequence.size(); b-->0; )
            {
                const Match& m = sequence[b];
                bool dup = false;
                for(size_t a=0; a< head->predecessors.size(); ++a)
                {
                    if(m == head->predecessors[a]->opcode)
                    {
                        head = head->predecessors[a];
                        dup = true;
                        break;
                    }
                }
                if(!dup)
                {
                    Node* newhead = new Node;
                    newhead->opcode = m;
                    head->predecessors.push_back(newhead);
                    head = newhead;
                }
            }

            if(*bufptr == '-' && bufptr[1] == '>')
            {
                head->opcode.has_operations = true;
                bufptr += 2;
                for(;;)
                {
                    while(*bufptr == ' ' || *bufptr == '\t') ++bufptr;
                    if(*bufptr == '#' || *bufptr == '\r' || *bufptr == '\n') break;
                    Operation op;
                    if(*bufptr == '[')
                    {
                        size_t balance = 0; ++bufptr;
                        while(*bufptr != ']' || balance != 0)
                        {
                            if(*bufptr == '\r' || *bufptr == '\n') break;
                            if(*bufptr == '[') ++balance;
                            if(*bufptr == ']') --balance;
                            op.result += *bufptr++;
                        }
                        if(*bufptr == ']') ++bufptr;
                        op.type = Operation::Immed;
                    }
                    else
                    {
                        while(isalnum(*bufptr))
                            op.result += *bufptr++;
                        op.type = Operation::Opcode;
                    }
                    head->opcode.operations.push_back(op);
                }
            }
        }
    }
}

int main()
{
    Parse();
    Generate(std::cout);
    return 0;
}
