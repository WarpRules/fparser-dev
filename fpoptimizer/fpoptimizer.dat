# This datafile documents all the possible optimizations that the optimizer can/should do
#
# It is the plan that in the future, this should be autogenerated into code
#
#

# Substitution rule syntax:
#
# %token NUMERIC_CONSTANT     # literals such as 0, 1, 1.5 or CONSTANT_DR, CONSTANT_L10I
# %token PARAMETER_TOKEN      # placeholders such as x, y, a, b
# %token PLACEHOLDER_TOKEN    # placeholders such as <1>, <2>, <7>
# %token IMMED_TOKEN          # placeholders % and &
# %token BUILTIN_FUNC_NAME    # such as COS, CEIL, POW, +, *, MIN, MAX
# %token OPCODE               # opcodes
# %token UNARY_TRANSFORMATION  # /, -, !  # inverts/negates/inverts the param
# %token NEWLINE              # newline
#
# %token SUBST_OP_COLON       # :
# %token SUBST_OP_ARROW       # ->
#
# %%
#     grammar:
#       grammar substitution
#     | grammar NEWLINE
#     | /* empty */
#     ;
#
#     substitution:
#       function SUBST_OP_ARROW param NEWLINE
#       /* Entire function is changed into the particular param */
#
#     | function SUBST_OP_ARROW function NEWLINE
#       /* Entire function changes, the param_notinv_list is rewritten */
#       /* NOTE: "p x -> o y"  is a shortcut for "p x -> (o y)"  */
#
#     | function SUBST_OP_COLON  paramlist NEWLINE
#       /* The params provided are replaced with the new param_maybeinv_list */
#     ;
#
#     function:
#        OPCODE '[' paramlist ']'
#        /* Match a function with opcode=opcode,
#         * and the exact parameter list as specified
#         */
#        OPCODE '{' paramlist '}'
#        /* Match a function with opcode=opcode,
#         * and the exact parameter list in any order
#         */
#     |  OPCODE paramlist
#        /* Match a function with opcode=opcode and the given way of matching params */
#        /* There may be more parameters, don't care about them */
#     ;
#
#     paramlist: /* left-recursive list of 0-n params with no delimiter */
#         paramlist '~' param /* negated/inverted param */
#       | paramlist param
#       | /* empty */
#     ;
#
#     param:
#        NUMERIC_CONSTANT         /* particular immed */
#     |  IMMED_TOKEN              /* a placeholder for some immed */
#     |  BUILTIN_FUNC_NAME '(' paramlist ')'  /* literal logarithm/sin/etc. of the provided immed-type params -- also sum/product/minimum/maximum */
#     |  UNARY_TRANSFORMATION param   /* the negated/inverted literal value of the param */
#     |  PARAMETER_TOKEN          /* any expression, indicated by "x", "a" etc. */
#     |  PARAMETER_TOKEN '+'      /* any expression, indicated by "x", "a" etc, repeated 2..N times. */
#     |  PARAMETER_TOKEN '*'      /* any expression, indicated by "x", "a" etc, repeated 1..N times. */
#     |  '(' function ')'         /* a subtree */
#     |  PLACEHOLDER_TOKEN        /* a placeholder for all params */
#     ;


[ENTRY]
# These optimizations are done only once, before the intermediate conversions.
# This process converts some optimized opcodes into primitives, so as to
# make the intermediate optimizations simpler to write. In the final stage,
# the optimized opcodes are reconstructed where available.

# x / y = x * 1/y
# Note: Already done by bytecode interpreter
#cDiv  [x y] -> cMul [x ~y]
#cRDiv [y x] -> cMul [x ~y]

# x - y = x + -y
# Note: Already done by bytecode interpreter
#cSub  [x y] -> cAdd [x ~y]
#cRSub [y x] -> cAdd [x ~y]

# 1/x   = <implied> * ~x
# Note: Already done by bytecode interpreter
#cInv [x]   -> cMul [~x]

# -x    = <implied> + -x
# Note: Already done by bytecode interpreter
#cNeg [x]   -> cAdd [~x]

# deg(x) = x * CONSTANT_DR
# Note: Already done by bytecode interpreter
#cDeg [x]   -> cMul [x CONSTANT_DR]

# rad(x) = x * CONSTANT_RD
# Note: Already done by bytecode interpreter
#cRad [x]   -> cMul [x CONSTANT_RD]

# cot(x) = <implied> * ~tan(x)
# Note: Already done by bytecode interpreter
#cCot [x]   -> cMul [~(cTan [x])]

# csc(x) = <implied> * ~sin(x)
# Note: Already done by bytecode interpreter
#cCsc [x]   -> cMul [~(cSin [x])]

# sec(x) = <implied> * ~cos(x)
# Note: Already done by bytecode interpreter
#cSec [x]   -> cMul [~(cCos [x])]

# sqrt(x) = x^0.5
# Note: Already done by bytecode interpreter
#cSqrt [x]  -> cPow [x 0.5]

# sqr(x) = x*x
# Note: Already done by bytecode interpreter
#cSqr [x]   -> cMul [x x]

# exp(x) = CONSTANT_E^x
# Note: Already done by bytecode interpreter
#cExp [x]    -> cPow [CONSTANT_E x]

# log10(x) = log(x) * CONSTANT_L10I
# Note: Already done by bytecode interpreter
#cLog10 [x]  -> cMul [(cLog [x]) CONSTANT_L10I]

# log2(x) = log(x) * CONSTANT_L2I
# Note: Already done by bytecode interpreter
#cLog2 [x]   -> cMul [(cLog [x]) CONSTANT_L2I]

# not(not(x)) = notnot(x)
# Do this so that !!x won't get inadvertedly optimized into x
# However, optimizing !!!x into !x is allright, and we do quite
# many things relating to cNot, so cNotNot helps protecting the
# one special case without having to repeat protections everywhere.
cNot[(cNot [x])] -> cNotNot [x]

[INTERMEDIATE]

#### Remove redundant components:

# In a add-list, having x and -x gets both deleted
cAdd x ~x  :
# In a mul-list,  having x and 1/x gets both deleted
cMul x ~x  :
# In a add-list, immeds having the value 0 are deleted
cAdd 0     :
# In a mul-list, immeds having the value 1 are deleted
cMul  1    :
# In a mul-list, an occurrence of the immed 0 deletes all items
cMul  0    -> 0
# In a min-list, two identical components are reduced into one
cMin x x    : x
# In a max-list, two identical components are reduced into one
cMax x x    : x

# If both branches of an If() are identical, the test becomes unnecessary
cIf [y x x] -> x
# If the If() condition never matches, take the else-branch
cIf [0 x y] -> y
# If the If() condition always matches, take the then-branch
cIf [1 x y] -> x
# If the If() condition begins with a not, remove the not and swap the branches
cIf [(cNot x) y z]    -> cIf [x z y]
# Notnots are unnecessary in an If()
cIf [(cNotNot x) y z] -> cIf [x y z]

# There are more optimizations that could be done with If(),
# but they are likely too specific.
# For example:
cIf [y       x           (cAdd x <1> ~<2>)] -> cAdd[x (cIf [y 0               (cAdd <1> ~<2>)])]
cIf [y (cAdd x <1> ~<2>) (cAdd x <3> ~<4>)] -> cAdd[x (cIf [y (cAdd <1> ~<2>) (cAdd <3> ~<4>)])]
cIf [y       x           (cMul x <1> ~<2>)] -> cMul[x (cIf [y 1               (cMul <1> ~<2>)])]
cIf [y (cMul x <1> ~<2>) (cMul x <3> ~<4>)] -> cMul[x (cIf [y (cMul <1> ~<2>) (cMul <3> ~<4>)])]
cIf [y       x           (cAnd x <1> ~<2>)] -> cAnd[x (cIf [y 0               (cAnd <1> ~<2>)])]
cIf [y (cAnd x <1> ~<2>) (cAnd x <3> ~<4>)] -> cAnd[x (cIf [y (cAnd <1> ~<2>) (cAnd <3> ~<4>)])]
cIf [y       x           (cOr  x <1> ~<2>)] -> cOr [x (cIf [y 1               (cOr  <1> ~<2>)])]
cIf [y (cOr  x <1> ~<2>) (cOr  x <3> ~<4>)] -> cOr [x (cIf [y (cOr  <1> ~<2>) (cOr  <3> ~<4>)])]


#### Flattening the topology of add/mul/min/max/and/or groups:

# If a add-list contains another add-list, assimilate the child (but xor the signs)
cAdd  (cAdd <1> ~<2>)  :  <1> ~<2>
cAdd ~(cAdd <1> ~<2>)  : ~<1>  <2>

# If a mul-list contains another mul-list, assimilate the child (but xor the signs)
cMul  (cMul <1> ~<2>)  :  <1> ~<2>
cMul ~(cMul <1> ~<2>)  : ~<1>  <2>

# If a min-list contains another min-list, assimilate the child
cMin (cMin <1>)   : <1>

# If a max-list contains another max-list, assimilate the child
cMax (cMax <1>)   : <1>

# If an and-list contains not-tokens, assimilate those not-tokens
cAnd  (cNot[x])   : ~x
cAnd ~(cNot[x])   : x

# A notnot in and-lists is redundant:
cAnd  (cNotNot[x]) :  x
cAnd ~(cNotNot[x]) : ~x

# If an or-list contains not-tokens, assimilate those not-tokens
cOr  (cNot[x])   : ~x
cOr ~(cNot[x])   : x

# A notnot in or-lists is redundant:
cOr   (cNotNot[x]) :  x
cOr  ~(cNotNot[x]) : ~x

# If an and-list contains another and-list, assimilate the child
cAnd  (cAnd <1> ~<2>)  : <1> ~<2>
cAnd ~(cAnd <1> ~<2>)  : ~<1> <2>

# If an or-list contains another or-list, assimilate the child
cOr  (cOr <1> ~<2>)  : <1> ~<2>
cOr ~(cOr <1> ~<2>)  : ~<1> <2>

# Two notnots make one
cNotNot [(cNotNot[x])] : x
# A notnot-not is better expressed as not-notnot
cNotNot [(cNot[x])] -> cNot [(cNotNot [x])]


#### Simplify empty groups:

# An empty min-list gets replaced with immed NaN
cMin  []   -> NaN
# An empty max-list gets replaced with immed NaN
cMax  []   -> NaN
# An empty add-list gets replaced with immed 0
cAdd  []   -> 0
# An empty mul-list gets replaced with immed 1
cMul  []   -> 1
# An empty and-list gets replaced with immed 0
cAnd  []   -> 0
# An empty or-list gets replaced with immed 1
cOr   []   -> 1

# A single-token min-list gets replaced with that single token
cMin [x]   -> x
# A single-token max-list gets replaced with that single token
cMax [x]   -> x
# A single-token add-list gets replaced with that single token (note: NOT when negated)
cAdd [x]   -> x
# A single-token mul-list gets replaced with that single token (note: NOT when inverted)
cMul [x]   -> x
# A single-token and-list gets replaced with that single token
cAnd [x]   -> x
cAnd [~x]  -> cNot [x]
# A single-token or-list gets replaced with that single token
cOr  [x]   -> x
cOr  [~x]  -> cNot [x]
# If a pow has an exponent of 1, replace the pow with the base value
cPow [x 1] -> x
# If a pow has an exponent of 0, replace the pow with immed 1 (note: this makes 0^0 evaluate into 1, too)
cPow [x 0] -> 1

# A single-token and-list gets replaced with a notnot
cAnd [x]  -> cNotNot [x]
# A single-token or-list gets replaced with a notnot
cOr [x]  -> cNotNot [x]


#### Linear combining

# If a mul-list contains the same element four or more times,
# replace the element with a pow with an integer exponent
# (note: inversions are treated as a negative exponent)
# e.g. ...*x*x*x*x = ...*x^4
cMul  x+                   : (cPow  x  x+)
cMul ~x+                   : (cPow [x -x+])
# x^3 * x = x^4
cMul  x*       (cPow[x %]) : (cPow [x +(x* %)])
cMul  x*      ~(cPow[x %]) : (cPow [x +(x* -%)])
cMul ~x*       (cPow[x %]) : (cPow [x +(-x* %)])
cMul ~x*      ~(cPow[x %]) : (cPow [x +(-x* -%)])
# x^y * x^z = x^(y+z)
cMul  (cPow[x y])  (cPow[x z]) : (cPow [x (cAdd [y z])])
# x^y / x^z = x^(y-z)
cMul  (cPow[x y]) ~(cPow[x z]) : (cPow [x (cAdd [y ~z])])
# 1 / x^y / x^z = x^(-y-z)
cMul ~(cPow[x y]) ~(cPow[x z]) : (cPow [x (cAdd [~y ~z])])

# If an add-list contains the same element four or more times,
# replace the element with a mul with an integer factor
# (note: negations are treated as a negative factor)
# e.g. ...+x+x+x+x -> ...+x*4
cAdd  x+                           :  (cMul  x   x+)
cAdd ~x+                           : ~(cMul  x   x+)

# Note: existence of x+ ~x+ is already dealt with by "cAdd x ~x :".
# x*3 + x*z*y = x*(3+z*y)
cAdd  x*          (cMul x <1> ~<2>)    : (cMul [x   (cAdd   x*  (cMul <1> ~<2>) )])
cAdd  x*         ~(cMul x <1> ~<2>)    : (cMul [x   (cAdd   x* ~(cMul <1> ~<2>) )])
cAdd ~x*          (cMul x <1> ~<2>)    : (cMul [x   (cAdd  ~x*  (cMul <1> ~<2>) )])
cAdd ~x*         ~(cMul x <1> ~<2>)    : (cMul [x   (cAdd  ~x* ~(cMul <1> ~<2>) )])

## a*b*c*p*q + a*b*c*r*s = a*b*c*(p*q + r*s)
#cAdd  (cMul <1> <2> ~<4>)  (cMul <1> <3> ~<5>) : (cMul <1> (cAdd  (cMul <2> ~<4>)  (cMul <3> ~<5>)))
#cAdd  (cMul <1> <2> ~<4>) ~(cMul <1> <3> ~<5>) : (cMul <1> (cAdd  (cMul <2> ~<4>) ~(cMul <3> ~<5>)))
#cAdd ~(cMul <1> <2> ~<4>) ~(cMul <1> <3> ~<5>) : (cMul <1> (cAdd ~(cMul <2> ~<4>) ~(cMul <3> ~<5>)))
#
## Note: The above might be difficult to match efficiently.
## The below is a simpler version that only works with a single operand...
#cAdd  (cMul <1> ~<2> x)  (cMul <1> ~<2> y)  : (cMul <1> ~<2> (cAdd [ x  y]))
#cAdd  (cMul <1> ~<2> x) ~(cMul <1> ~<2> y)  : (cMul <1> ~<2> (cAdd [ x ~y]))
#cAdd ~(cMul <1> ~<2> x) ~(cMul <1> ~<2> y)  : (cMul <1> ~<2> (cAdd [~x ~y]))

# Note: The above might be still difficult to match.
# The below is an even simpler version...
cAdd  (cMul x <1> ~<3>)  (cMul x <2> ~<4>)   : (cMul [x (cAdd  (cMul <1> ~<3>)  (cMul <2> ~<4>))])
cAdd  (cMul x <1> ~<3>) ~(cMul x <2> ~<4>)   : (cMul [x (cAdd  (cMul <1> ~<3>) ~(cMul <2> ~<4>))])
cAdd ~(cMul x <1> ~<3>) ~(cMul x <2> ~<4>)   : (cMul [x (cAdd ~(cMul <1> ~<3>) ~(cMul <2> ~<4>))])

# The below is still simpler version...
#cAdd  (cMul  x %)  (cMul  x &)         : (cMul [ x +(% &)])
#cAdd  (cMul  x %) ~(cMul  x &)         : (cMul [ x +(% -&)])
#cAdd ~(cMul  x %) ~(cMul  x &)         : (cMul [ x +(-% -&)])
#cAdd  (cMul ~x %)  (cMul ~x &)         : (cMul [~x +(% &)])
#cAdd  (cMul ~x %) ~(cMul ~x &)         : (cMul [~x +(% -&)])
#cAdd ~(cMul ~x %) ~(cMul ~x &)         : (cMul [~x +(-% -&)])

#### Remote double negations/inversions

# If an addlist contains a negated mul and that mul-list contains a factor,
# un-negate the mul-list and negate the factor in the mul-list.
cAdd ~(cMul % <1> ~<2>)      : (cMul -% <1> ~<2>)

# If a mul-list contains an inverted pow and the exponent is an immed,
# un-negate the pow and negate the immed.
cMul ~(cPow [x %])           : (cPow [x -%])

# (x^y)^z        -> x^(y*z)
cPow [ (cPow[x y]) z ]       : x (cMul [y z])

# (x^y) * (x^z) -> x^(y+z)
cMul (cPow[x y]) (cPow[x z]) : (cPow [x (cAdd [y z])])


#### Constant folding:

# Negate literal negated params...
cAdd ~%      : -%
# Note: Don't invert literal inverted params liberally; doing so may lose precision.

# If a add-list contains two or more immeds, replace those immeds
# with a single non-negated immed that has the sum of those original
# immeds.
cAdd  %  &   : +(% &)

# If a mul-list contains two or more immeds, replace those immeds
# with a single non-inverted immed that has the product of those original
# immeds (paying attention to the polarity of those immeds)
cMul  %  &   : *(% &)
cMul  % ~&   : *(% /&)
# Note: To preserve precision, this is not done as *(/# /&).
cMul ~% ~&   : ~*(% &)

# If a min-list contains two or more immeds, replace those immeds
# with a single immed that is the minimum of the original immeds
cMin % &     : MIN(% &)

# If a max-list contains two or more immeds, replace those immeds
# with a single immed that is the maximum of the original immeds
cMax % &     : MAX(% &)

# Function call optimization with constant params
# such as sin(immed)->newimmed, log(immed)->newimmed etc.
cSin[%]      -> SIN(%)
cCos[%]      -> COS(%)
cTan[%]      -> TAN(%)
cAsin[%]     -> ASIN(%)
cAcos[%]     -> ACOS(%)
cAtan[%]     -> ATAN(%)
cSinh[%]     -> SINH(%)
cCosh[%]     -> COSH(%)
cTanh[%]     -> TANH(%)
cAsinh[%]    -> ASINH(%)
cAcosh[%]    -> ACOSH(%)
cAtanh[%]    -> ATANH(%)
cPow[% &]    -> POW(% &)
cCeil[%]     -> CEIL(%)
cFloor[%]    -> FLOOR(%)
cLog[%]      -> LOG(%)
cMod[% &]    -> MOD(% &)
# TODO: equal,nequal,less,lessoreq,greater,greatoreq,not,and,or


#### Logical optimizations

# Repetitions in and-lists don't help
cAnd  x x   : x
cAnd ~x ~x  : ~x
# Nor in or-lists
cOr   x  x  : x
cOr  ~x ~x  : ~x

# In an and-list, having x and !x invalides the whole list
cAnd x ~x   -> 0

# In an or-list, having x and !x validates the whole list
cOr x ~x    -> 1

# Eschew so many negations.
#   !a & !b = !(a | b)
cAnd ~a ~b ~<1> : ~(cOr a b <1>)
#   !a | !b = !(a & b)
cOr ~a ~b ~<1>  : ~(cAnd a b <1>)

cAnd ~(cNEqual[a b])      : (cEqual[a b])
cAnd ~(cEqual[a b])       : (cNEqual[a b])
cAnd ~(cLess[a b])        : (cGreaterOrEq[a b])
cAnd ~(cGreater[a b])     : (cLessOrEq[a b])
cAnd ~(cLessOrEq[a b])    : (cGreater[a b])
cAnd ~(cGreaterOrEq[a b]) : (cLess[a b])
cOr ~(cNEqual[a b])       : (cEqual[a b])
cOr ~(cEqual[a b])        : (cNEqual[a b])
cOr ~(cLess[a b])         : (cGreaterOrEq[a b])
cOr ~(cGreater[a b])      : (cLessOrEq[a b])
cOr ~(cLessOrEq[a b])     : (cGreater[a b])
cOr ~(cGreaterOrEq[a b])  : (cLess[a b])
cNot [(cNEqual[a b])]      -> cEqual[a b]
cNot [(cEqual[a b])]       -> cNEqual[a b]
cNot [(cLess[a b])]        -> cGreaterOrEq[a b]
cNot [(cGreater[a b])]     -> cLessOrEq[a b]
cNot [(cLessOrEq[a b])]    -> cGreater[a b]
cNot [(cGreaterOrEq[a b])] -> cLess[a b]
cNotNot [(cNEqual[a b])]      -> cNEqual[a b]
cNotNot [(cEqual[a b])]       -> cEqual[a b]
cNotNot [(cLess[a b])]        -> cLess[a b]
cNotNot [(cGreater[a b])]     -> cGreater[a b]
cNotNot [(cLessOrEq[a b])]    -> cLessOrEq[a b]
cNotNot [(cGreaterOrEq[a b])] -> cGreaterOrEq[a b]
cNotNot [(cAnd <1> ~<2>)]     -> cAnd <1> ~<2>
cNotNot [(cOr  <1> ~<2>)]     -> cOr  <1> ~<2>

# From logic, follows that...
#   (a==b) & (b==c) & (a==c) -- one of these is redundant
cAnd (cEqual a b) (cEqual b c) (cEqual a c)  : (cEqual [a b]) (cEqual [b c])
#   (a==b) & (a!=b)          -- this statement is always false
cAnd (cEqual a b) (cNEqual a b) -> 0
#   (a==b) | (a!=b)          -- this statement is always true
cOr  (cEqual a b) (cNEqual a b) -> 1
#   (a==b) & (a==b)          -- one of these is redundant

#   x==x -- this statement is always true (note: might be not when we have NaN, but we don't care)
cEqual[x x]                     -> 1
cLessOrEq[x x]                  -> 1
cGreaterOrEq[x x]               -> 1
#   x!=x -- this statement is always false (note: we ignore NaN cases)
cNEqual[x x]                    -> 1
cLess[x x]                      -> 1
cGreater[x x]                   -> 1



#### Logarithm optimizations
# log(pow(X,Y))/log(X) = Y

cMul  (cLog[(cPow [x y])]) ~(cLog[x])  : y
cMul ~(cLog[(cPow [x y])])  (cLog[x])  : ~y

cMul  (cLog[(cPow [% y])]) ~LOG(%)  : y
cMul ~(cLog[(cPow [% y])])  LOG(%)  : ~y

# CONSTANT_E^log(x) = x
cPow [CONSTANT_E (cLog[x])]   -> x

# CONSTANT_E^(log(x)*y) = x^y
cPow [CONSTANT_E (cMul (cLog[x]) <1> ~<2>)]   : x (cMul <1> ~<2>)

# z^(log(x)/log(z)*y) = x^y
cPow [z (cMul ~(cLog[z]) (cLog[x]) <1> ~<2>)] : x (cMul <1> ~<2>)

# log(x^z) = z * log(x)
cLog [(cPow [x z])] -> cMul [z (cLog [x])]

# log(x) + log(y) + log(z) = log(x*y*z)
cAdd (cLog[x]) (cLog[y]) : (cLog (cMul x y))

# log(x * CONSTANT_E^y) = log(x) + y
cLog [(cMul (cPow [CONSTANT_E y]) <1> ~<2>)] -> cAdd [(cLog [(cMul <1> ~<2>)]) y]

# log(x * z^y) / log(z) = log(x) / log(z) + y
# Note: z can also be an immed
cMul (cLog [(cMul x (cPow [z y]))]) ~(cLog[z])  -> cAdd [(cMul [(cLog [x]) ~(cLog [z])]) y]
cMul (cLog [(cMul x (cPow [% y]))]) ~LOG(%)     -> cAdd [(cMul [(cLog [x]) ~LOG(%)]) y]


#### Trigonometric:
# sin(x)/cos(x) = tan(x)
cMul  (cSin[x]) ~(cCos[x]) :  (cTan[x])
cMul ~(cSin[x])  (cCos[x]) : ~(cTan[x])
cMul  (cSinh[x]) ~(cCosh[x]) :  (cTanh[x])
cMul ~(cSinh[x])  (cCosh[x]) : ~(cTanh[x])

# cos(pi/2 - x) = sin(x)
cCos [(cAdd *(CONSTANT_PI 0.5) x)] -> cSin[x]
# sin(pi/2 - x) = cos(x)
cSin [(cAdd *(CONSTANT_PI 0.5) x)] -> cCos[x]
# cot(pi/2 - x) = 1/tan(pi/2 - x) = tan(x)
cMul [~(cTan [(cAdd *(CONSTANT_PI 0.5) x)])] -> cTan[x]

# sin(x)^2 + cos(x)^2 = 1
cAdd  (cPow[ (cSin[x]) 2]) (cPow [(cCos[x]) 2]) : 1
# y-sin(x)^2 = cos(x)^2+(y-1)
# y-cos(x)^2 = sin(x)^2+(y-1)
cAdd 1 ~(cPow[ (cSin[x]) 2]) : (cPow [(cCos[x]) 2])
cAdd 1 ~(cPow[ (cCos[x]) 2]) : (cPow [(cSin[x]) 2])

# sin(x)*cos(y) + cos(x)*sin(y) = sin(x+y)
# sin(x)*cos(y) - cos(x)*sin(y) = sin(x-y)
# cos(x)*cos(y) + sin(x)*sin(y) = cos(x+y)
# cos(x)*cos(y) - sin(x)*sin(y) = cos(x-y)

cAdd  (cMul {(cSin[x]) (cCos[y])})  (cMul {(cCos[x]) (cSin[y])}) : (cSin (cAdd[x  y]))
cAdd  (cMul {(cSin[x]) (cCos[y])}) ~(cMul {(cCos[x]) (cSin[y])}) : (cSin (cAdd[x ~y]))
cAdd  (cMul {(cCos[x]) (cCos[y])})  (cMul {(cSin[x]) (cSin[y])}) : (cCos (cAdd[x  y]))
cAdd  (cMul {(cCos[x]) (cCos[y])}) ~(cMul {(cSin[x]) (cSin[y])}) : (cCos (cAdd[x ~y]))

cAdd ~(cMul {(cSin[x]) (cCos[y])}) ~(cMul {(cCos[x]) (cSin[y])}) : ~(cSin (cAdd[x  y]))
cAdd ~(cMul {(cCos[x]) (cCos[y])}) ~(cMul {(cSin[x]) (cSin[y])}) : ~(cCos (cAdd[x  y]))
cAdd ~(cMul {(cCos[x]) (cCos[y])})  (cMul {(cSin[x]) (cSin[y])}) : ~(cCos (cAdd[x ~y]))
# This one is redudant, I think:
#cAdd ~(cMul {(cSin[x]) (cCos[y])})  (cMul {(cCos[x]) (cSin[y])}) : ~(cSin (cAdd[x ~y]))

#### Polynomic:
# x*y + z*y = (x+z)*y
# x/y + z/y = (x+z)/y
cAdd (cMul  y <1> ~<3>) (cMul  y <2> ~<4>)  : (cMul [ y (cAdd (cMul <1> ~<3>) (cMul <2> ~<4>))])
cAdd (cMul ~y <1> ~<3>) (cMul ~y <2> ~<4>)  : (cMul [~y (cAdd (cMul <1> ~<3>) (cMul <2> ~<4>))])



#### Self-defeating function calls:
# sin(asin(x)) = x
cSin [(cAsin [x])] -> x

# cos(acos(x)) = x
cCos [(cAcos [x])] -> x

# tan(atan(x)) = x
cTan [(cAtan [x])] -> x

# Note: asin(sin(x)) must not be converted, because
# even though asin(sin(1.1)) = 1.1, asin(sin(1500)) != 1500.


[FINAL]
# These optimizations are done only once, after the intermediate conversions.
# This process generates optimized opcodes that are not expected to be found
# in the intermediate stage.
#
# Do not generate cDiv, cRDiv, cInv, cSub, cRSub, cNeg or cNot here.
# Those are done in the bytecode generation automatically.
#

# x * CONSTANT_DR = cDeg(x)
# x * ~CONSTANT_RD = cDeg(x)
cMul  CONSTANT_DR <1> ~<2> -> cDeg [(cMul <1> ~<2>)]
cMul ~CONSTANT_RD <1> ~<2> -> cDeg [(cMul <1> ~<2>)]
# Note: This may produce one-operand cMul lists.
# Those are treated properly in the bytecode generation,
# and do not need to be handled by [INTERMEDIATE].

# x * CONSTANT_RD = cRad(x)
# x * ~CONSTANT_DR = cRad(x)
cMul  CONSTANT_RD <1> ~<2> -> cRad [(cMul <1> ~<2>)]
cMul ~CONSTANT_DR <1> ~<2> -> cRad [(cMul <1> ~<2>)]

# x^0.5 = sqrt(x)
cPow [x 0.5]         -> cSqrt [x]

# pow(CONSTANT_E, x) = exp(x)
cPow [CONSTANT_E x]  -> cExp [x]

# log(x) / CONSTANT_L10  = log10(x)
cMul  (cLog [x]) ~CONSTANT_L10  :  (cLog10 [x])
cMul  (cLog [x]) CONSTANT_L10I  :  (cLog10 [x])
cMul ~(cLog [x])   CONSTANT_L10 : ~(cLog10 [x])
cMul ~(cLog [x]) ~CONSTANT_L10I : ~(cLog10 [x])

# log(x) / CONSTANT_L2 = log2(x)
cMul  (cLog [x]) ~CONSTANT_L2  :  (cLog2 [x])
cMul  (cLog [x]) CONSTANT_L2I  :  (cLog2 [x])
cMul ~(cLog [x])   CONSTANT_L2 : ~(cLog2 [x])
cMul ~(cLog [x]) ~CONSTANT_L2I : ~(cLog2 [x])

# In a mul-list, ~sin(x) = csc(x)
cMul ~(cSin [x])      : (cCsc [x])

# In a mul-list, ~cos(x) = sec(x)
cMul ~(cCos [x])      : (cSec [x])

# In a mul-list, ~tan(x) = cot(x)
cMul ~(cTan [x])      : (cCot [x])

# These should not occur after [INTERMEDIATE]
#cMul x x              :  (cSqr[x])
#cMul ~x ~x            : ~(cSqr[x])

# Do not reduce add/mul/min/max/and/or lists to two-operand topology
# Those are done in the bytecode generation automatically.

# Unprotect not-not
cNotNot[x]     -> cNot [(cNot [x])]
