# This datafile documents all the possible optimizations that the optimizer can/should do
#
# It is the plan that in the future, this should be autogenerated into code
#
#

# Substitution rule syntax:
#
# %token NUMERIC_CONSTANT     # literals such as 0, 1, 1.5 or CONSTANT_DR, CONSTANT_L10I
# %token PARAMETER_TOKEN      # placeholders such as x, y, a, b
# %token PLACEHOLDER_TOKEN    # placeholders such as <1>, <2>, <7>
# %token IMMED_TOKEN          # placeholders % and &
# %token BUILTIN_FUNC_NAME    # such as COS, CEIL, POW, +, *, MIN, MAX
# %token OPCODE               # opcodes
# %token UNARY_TRANSFORMATION  # /, -, !  # inverts/negates/inverts the param
# %token NEWLINE              # newline
#
# %token SUBST_OP_COLON       # :
# %token SUBST_OP_ARROW       # ->
#
# %%
#     grammar:
#       grammar substitution
#     | grammar NEWLINE
#     | /* empty */
#     ;
#
#     substitution:
#       function SUBST_OP_ARROW param NEWLINE
#       /* Entire function is changed into the particular param */
#
#     | function SUBST_OP_ARROW function NEWLINE
#       /* Entire function changes, the param_notinv_list is rewritten */
#       /* NOTE: "p x -> o y"  is a shortcut for "p x -> (o y)"  */
#
#     | function SUBST_OP_COLON  paramlist NEWLINE
#       /* The params provided are replaced with the new param_maybeinv_list */
#     ;
#
#     function:
#        OPCODE '[' paramlist sign_spec ']'
#        /* Match a function with opcode=opcode,
#         * and the exact parameter list as specified
#         */
#        OPCODE '{' paramlist sign_spec '}'
#        /* Match a function with opcode=opcode,
#         * and the exact parameter list in any order
#         */
#     |  OPCODE paramlist sign_spec
#        /* Match a function with opcode=opcode and the given way of matching params */
#        /* There may be more parameters, don't care about them */
#     ;
#
#     paramlist: /* left-recursive list of 0-n params with no delimiter */
#         paramlist '~' param /* negated/inverted param */
#       | paramlist param
#       | /* empty */
#     ;
#
#     sign_spec: /* Can be used to specify a proportion of negativeness to positiveness */
#         '=-' /* ~<number> matched more elements than <number> did */
#       | '=+' /* ~<number> matched fewer elements than <number> did */
#       | '==' /* ~<number> matched as many elements than <number> did */
#       | /* empty */
#     ;
#
#     param:
#        NUMERIC_CONSTANT         /* particular immed */
#     |  IMMED_TOKEN              /* a placeholder for some immed */
#     |  BUILTIN_FUNC_NAME '(' paramlist ')'  /* literal logarithm/sin/etc. of the provided immed-type params -- also sum/product/minimum/maximum */
#     |  UNARY_TRANSFORMATION param   /* the negated/inverted literal value of the param */
#     |  PARAMETER_TOKEN          /* any expression, indicated by "x", "a" etc. */
#     |  PARAMETER_TOKEN '+'      /* any expression, indicated by "x", "a" etc, repeated 2..N times. */
#     |  PARAMETER_TOKEN '*'      /* any expression, indicated by "x", "a" etc, repeated 1..N times. */
#     |  '(' function ')'         /* a subtree */
#     |  PLACEHOLDER_TOKEN        /* a placeholder for all params */
#     ;


[ENTRY]
# These optimizations are done only once, before the intermediate conversions.
# This process converts some optimized opcodes into primitives, so as to
# make the intermediate optimizations simpler to write. In the final stage,
# the optimized opcodes are reconstructed where available.

# x / y = x * 1/y
# Note: Already done by bytecode interpreter
#cDiv  [x y] -> cMul [x ~y]
#cRDiv [y x] -> cMul [x ~y]

# x - y = x + -y
# Note: Already done by bytecode interpreter
#cSub  [x y] -> cAdd [x ~y]
#cRSub [y x] -> cAdd [x ~y]

# 1/x   = <implied> * ~x
# Note: Already done by bytecode interpreter
#cInv [x]   -> cMul [~x]

# -x    = <implied> + -x
# Note: Already done by bytecode interpreter
#cNeg [x]   -> cAdd [~x]

# deg(x) = x * CONSTANT_DR
# Note: Already done by bytecode interpreter
#cDeg [x]   -> cMul [x CONSTANT_DR]

# rad(x) = x * CONSTANT_RD
# Note: Already done by bytecode interpreter
#cRad [x]   -> cMul [x CONSTANT_RD]

# cot(x) = <implied> * ~tan(x)
# Note: Already done by bytecode interpreter
#cCot [x]   -> cMul [~(cTan [x])]

# csc(x) = <implied> * ~sin(x)
# Note: Already done by bytecode interpreter
#cCsc [x]   -> cMul [~(cSin [x])]

# sec(x) = <implied> * ~cos(x)
# Note: Already done by bytecode interpreter
#cSec [x]   -> cMul [~(cCos [x])]

# sqrt(x) = x^0.5
# Note: Already done by bytecode interpreter
#cSqrt [x]  -> cPow [x 0.5]

# sqr(x) = x*x
# Note: Already done by bytecode interpreter
#cSqr [x]   -> cMul [x x]

# exp(x) = CONSTANT_E^x
# Note: Already done by bytecode interpreter
#cExp [x]    -> cPow [CONSTANT_E x]

# log10(x) = log(x) * CONSTANT_L10I
# Note: Already done by bytecode interpreter
#cLog10 [x]  -> cMul [(cLog [x]) CONSTANT_L10I]

# log2(x) = log(x) * CONSTANT_L2I
# Note: Already done by bytecode interpreter
#cLog2 [x]   -> cMul [(cLog [x]) CONSTANT_L2I]

# not(not(x)) = notnot(x)
# Do this so that !!x won't get inadvertedly optimized into x
# However, optimizing !!!x into !x is allright, and we do quite
# many things relating to cNot, so cNotNot helps protecting the
# one special case without having to repeat protections everywhere.
cNot[(cNot [x])] -> cNotNot [x]

[INTERMEDIATE]

#### Remove redundant components:

# In a add-list, having x and -x gets both deleted
cAdd x ~x  :
# In a mul-list,  having x and 1/x gets both deleted
cMul x ~x  :
# In a add-list, immeds having the value 0 are deleted
cAdd 0     :
# In a mul-list, immeds having the value 1 are deleted
cMul  1    :
# In a mul-list, an occurrence of the immed 0 deletes all items
cMul  0    -> 0
# In a min-list, two identical components are reduced into one
cMin x x    : x
# In a max-list, two identical components are reduced into one
cMax x x    : x

# If both branches of an If() are identical, the test becomes unnecessary
cIf [y x x] -> x
# If the If() condition never matches, take the else-branch
cIf [0 x y] -> y
# If the If() condition always matches, take the then-branch
cIf [1 x y] -> x
# If the If() condition begins with a not, remove the not and swap the branches
cIf [(cNot x) y z]    -> cIf [x z y]
# Notnots are unnecessary in an If()
cIf [(cNotNot x) y z] -> cIf [x y z]

# There are more optimizations that could be done with If(),
# but they are likely too specific.
# For example:
#  Move branch invariants. if(y, x+a, x+b) -> x+if(y, a, b)
cIf [y       x           (cAdd x <1> ~<2>)] -> cAdd[x (cIf [y 0               (cAdd <1> ~<2>)])]
cIf [y (cAdd x <1> ~<2>) (cAdd x <3> ~<4>)] -> cAdd[x (cIf [y (cAdd <1> ~<2>) (cAdd <3> ~<4>)])]
cIf [y       x           (cMul x <1> ~<2>)] -> cMul[x (cIf [y 1               (cMul <1> ~<2>)])]
cIf [y (cMul x <1> ~<2>) (cMul x <3> ~<4>)] -> cMul[x (cIf [y (cMul <1> ~<2>) (cMul <3> ~<4>)])]
cIf [y       x           (cAnd x <1> ~<2>)] -> cAnd[x (cIf [y 0               (cAnd <1> ~<2>)])]
cIf [y (cAnd x <1> ~<2>) (cAnd x <3> ~<4>)] -> cAnd[x (cIf [y (cAnd <1> ~<2>) (cAnd <3> ~<4>)])]
cIf [y       x           (cOr  x <1> ~<2>)] -> cOr [x (cIf [y 1               (cOr  <1> ~<2>)])]
cIf [y (cOr  x <1> ~<2>) (cOr  x <3> ~<4>)] -> cOr [x (cIf [y (cOr  <1> ~<2>) (cOr  <3> ~<4>)])]


#### Flattening the topology of add/mul/min/max/and/or groups:

# If a add-list contains another add-list, assimilate the child (but xor the signs)
cAdd  (cAdd <1> ~<2>)  :  <1> ~<2>
cAdd ~(cAdd <1> ~<2>)  : ~<1>  <2>

# If a mul-list contains another mul-list, assimilate the child (but xor the signs)
cMul  (cMul <1> ~<2>)  :  <1> ~<2>
cMul ~(cMul <1> ~<2>)  : ~<1>  <2>

# If an add-list contains a mul-list with a negated entry, assimilate the negation.
# I.e.  a + b + (c * (-d-e+f))  ->  a + b - (c * (+d+e-f))
# Or    a + b - (c * (-d-e+f))  ->  a + b + (c * (+d+e-f))
cAdd  (cMul (cAdd <3> ~<4> =-) <1> ~<2>) : ~(cMul (cAdd ~<3> <4>) <1> ~<2>)
cAdd ~(cMul (cAdd <3> ~<4> =-) <1> ~<2>) :  (cMul (cAdd ~<3> <4>) <1> ~<2>)

# If a min-list contains another min-list, assimilate the child
cMin (cMin <1>)   : <1>

# If a max-list contains another max-list, assimilate the child
cMax (cMax <1>)   : <1>

# If an and-list contains not-tokens, assimilate those not-tokens
cAnd  (cNot[x])   : ~x
cAnd ~(cNot[x])   : x

# A notnot in and-lists is redundant:
cAnd  (cNotNot[x]) :  x
cAnd ~(cNotNot[x]) : ~x

# If an or-list contains not-tokens, assimilate those not-tokens
cOr  (cNot[x])   : ~x
cOr ~(cNot[x])   : x

# A notnot in or-lists is redundant:
cOr   (cNotNot[x]) :  x
cOr  ~(cNotNot[x]) : ~x

# If an and-list contains another and-list, assimilate the child
cAnd  (cAnd <1> ~<2>)  : <1> ~<2>
cAnd ~(cAnd <1> ~<2>)  : ~<1> <2>

# If an or-list contains another or-list, assimilate the child
cOr  (cOr <1> ~<2>)  : <1> ~<2>
cOr ~(cOr <1> ~<2>)  : ~<1> <2>

# Two notnots make one
cNotNot [(cNotNot[x])] : x
# A notnot-not is better expressed as not-notnot
cNotNot [(cNot[x])] -> cNot [(cNotNot [x])]


#### Simplify empty groups:

# An empty min-list gets replaced with immed NaN
#cMin  []   -> NaN
# An empty max-list gets replaced with immed NaN
#cMax  []   -> NaN
# An empty add-list gets replaced with immed 0
cAdd  []   -> 0
# An empty mul-list gets replaced with immed 1
cMul  []   -> 1
# An empty and-list gets replaced with immed 0
cAnd  []   -> 0
# An empty or-list gets replaced with immed 1
cOr   []   -> 1

# A single-token min-list gets replaced with that single token
cMin [x]   -> x
# A single-token max-list gets replaced with that single token
cMax [x]   -> x
# A single-token add-list gets replaced with that single token (note: NOT when negated)
cAdd [x]   -> x
# A single-token mul-list gets replaced with that single token (note: NOT when inverted)
cMul [x]   -> x
# A single-token and-list gets replaced with that single token
cAnd  [x]  -> cNotNot [x]
cAnd [~x]  -> cNot [x]
# A single-token or-list gets replaced with that single token
cOr   [x]  -> cNotNot [x]
cOr  [~x]  -> cNot [x]
# If a pow has an exponent of 1, replace the pow with the base value
cPow [x 1]  -> x
# If a pow has an exponent of -1, replace the pow with the base value inverted
cPow [x -1] -> cMul [~x]
# If a pow has an exponent of 0, replace the pow with immed 1 (note: this makes 0^0 evaluate into 1, too)
cPow [x 0]  -> 1
# 0 raised to anything is 0 (note: this makes 0^0 evaluate into 0, and potentially conflicts with the previous rule)
cPow [0 x]  -> 0
# 1 raised to anything is 1
cPow [1 x]  -> 1

#### Linear combining and polynomials

# If a mul-list contains the same element two or more times,
# replace the element with a pow with an integer exponent
# (note: inversions are treated as a negative exponent)
# e.g. ...*x*x*x*x = ...*x^4
cMul  x+                   : (cPow  x  x+)
cMul ~x+                   : (cPow [x -x+])
# x^3 * x = x^4
cMul  x*       (cPow[x y]) : (cPow [x (cAdd x* y)])
cMul  x*      ~(cPow[x y]) : (cPow [x (cAdd x* ~y)])
cMul ~x*       (cPow[x y]) : (cPow [x (cAdd -x* y)])
cMul ~x*      ~(cPow[x y]) : (cPow [x (cAdd -x* ~y)])
# x^y * x^z = x^(y+z)
cMul  (cPow[x y])  (cPow[x z]) : (cPow [x (cAdd [y z])])
# x^y / x^z = x^(y-z)
cMul  (cPow[x y]) ~(cPow[x z]) : (cPow [x (cAdd [y ~z])])
# 1 / x^y / x^z = x^(-y-z)
cMul ~(cPow[x y]) ~(cPow[x z]) : (cPow [x (cAdd [~y ~z])])
# x^3 + 



# If an add-list contains the same element two or more times,
# replace the element with a mul with an integer factor
# (note: negations are treated as a negative factor)
# e.g. ...+x+x+x+x -> ...+x*4
cAdd  x+                           :  (cMul  x   x+)
cAdd ~x+                           : ~(cMul  x   x+)

# Note: existence of x+ ~x+ is already dealt with by "cAdd x ~x :".
# x*3 + x*z*y = x*(3+z*y)
cAdd  x*          (cMul x <1> ~<2>)    : (cMul [x   (cAdd   x*  (cMul <1> ~<2>) )])
cAdd  x*         ~(cMul x <1> ~<2>)    : (cMul [x   (cAdd   x* ~(cMul <1> ~<2>) )])
cAdd ~x*          (cMul x <1> ~<2>)    : (cMul [x   (cAdd  ~x*  (cMul <1> ~<2>) )])
cAdd ~x*         ~(cMul x <1> ~<2>)    : (cMul [x   (cAdd  ~x* ~(cMul <1> ~<2>) )])

#  +(x*A*B/C) +(x*D*E/F) = x*(+A*B/C +D*E/F)
#cAdd  (cMul  x <1> ~<3>)  (cMul  x <2> ~<4>)   : (cMul [ x (cAdd  (cMul <1> ~<3>)  (cMul <2> ~<4>))])
#cAdd  (cMul  x <1> ~<3>) ~(cMul  x <2> ~<4>)   : (cMul [ x (cAdd  (cMul <1> ~<3>) ~(cMul <2> ~<4>))])
#cAdd ~(cMul  x <1> ~<3>) ~(cMul  x <2> ~<4>)   : (cMul [ x (cAdd ~(cMul <1> ~<3>) ~(cMul <2> ~<4>))])
#cAdd  (cMul ~x <1> ~<3>)  (cMul ~x <2> ~<4>)   : (cMul [~x (cAdd  (cMul <1> ~<3>)  (cMul <2> ~<4>))])
#cAdd  (cMul ~x <1> ~<3>) ~(cMul ~x <2> ~<4>)   : (cMul [~x (cAdd  (cMul <1> ~<3>) ~(cMul <2> ~<4>))])
#cAdd ~(cMul ~x <1> ~<3>) ~(cMul ~x <2> ~<4>)   : (cMul [~x (cAdd ~(cMul <1> ~<3>) ~(cMul <2> ~<4>))])

## x^2 + x*y = x*(x+y)
## Disabled. This rule conflicts with (x+y)^2 optimization.
#cAdd (cPow [x 2])  (cMul x <1> ~<2>) : (cMul x (cAdd x  (cMul <1> ~<2>)))
#cAdd (cPow [x 2]) ~(cMul x <1> ~<2>) : (cMul x (cAdd x ~(cMul <1> ~<2>)))

# Note: These rules can be applied recursively, causing
# that such as a*b*d*e*f - c*d*e*f*g is first
# changed   to d*(a*b*e*f - c*e*f*g)
# and then  to d*(f*(a*b*e - c*e*g))
# and then  to d*(f*(e*(a*b - c*g)))
# which yields d*f*e*(a*b - c*g)

#
# How about (a+b)*(c+d)?
# It becomes a*c + b*c + a*d + b*d...
# We would like to do optimizations like that in reverse.
# Using the rules specified above,
# a*c + b*c + a*d + b*d might be
# changed  to a*(c+d) + b*(c+d),
# and then to (a+b)*(c+d).
# This seems nice enough.
# But what about (a+b)*(a+b)? This expands into a^2 + 2*a*b + b^2.
# Or,      about (a-b)*(a-b)? This expands into a^2 - 2*a*b + b^2.
# Or,      about (a+b)*(a-b)? This expands into a^2 - b^2.
# It would be nice if these could also be converted back.
# At least we can handle this a^2 - b^2 special case:
#cAdd (cPow[a 2]) ~(cPow[b 2]) : (cMul [(cAdd[a b]) (cAdd[a ~b])])
# ^With this rule,   eval=0.241051 us, optimized = 0.065257 us
# ^Without the rule, eval=0.227828 us, optimized = 0.060658  us
# Tested expression was "pow(x,14)+pow(y,8)+x*x-y*y"
# Oh well. The benchmark results are too varying.
# It does generate some additional opcodes, but it gets one multiplication less.
# Since the difference is not very noticeable, don't use the rule.

# a^2 + a*b*X/Z + b^2 = (a+b)^2 + (X/Z-2)*(a*b)
cAdd (cPow[a 2]) (cPow[b 2]) (cMul a b <1> ~<2>) : (cPow [(cAdd [a b]) 2]) (cMul [a b (cAdd [(cMul <1> ~<2>) -2])])
# For optimizing x^2+2*x*y+y^2:
#  With this rule,    eval=0.287154 us, optimized = 0.0758879 us
#  Without this rule, eval=0.314538 us, optimized = 0.0831386 us
# For optimizing x^2+3*x*y+y^2:
#  With this rule,    eval=0.295956 us, optimized = 0.0781288 us
#  Without this rule, eval=0.300723 us, optimized = 0.075689 us
# The benchmark results seem too varying, so it is hard to tell
# whether this rule had some advantage. It _looks_ like it did
# though, so better keep it, I suppose. -Bisqwit
#
# How about this?
# (a+b+c)^2 = c^2 + 2*b*c + 2*a*c + b^2 + 2*a*b + a^2
# Seems that it becomes:
# a^2 + b^2 + c^2 + 2*((a+b)*c + a*b)
# Is it worth adding rule for making that into (a+b+c)^2?
# Too specific, I suppose.



cAdd (cMul <1> ~<2> <3> ~<4>)  (cMul <1> ~<2> <5> ~<6>) : (cMul <1> ~<2> (cAdd (cMul <3> ~<4>)  (cMul <5> ~<6>)))
cAdd (cMul <1> ~<2> <3> ~<4>) ~(cMul <1> ~<2> <5> ~<6>) : (cMul <1> ~<2> (cAdd (cMul <3> ~<4>) ~(cMul <5> ~<6>)))
# Note: The above two lines can require extremely time-consuming
#       searching.

# These are the same as above, but work also if pow() is expanded
# Note: It would work even with y and z instead of % and &, but we
# limit into numeric literals for simplicity.
cAdd (cMul (cPow[x %]) <3> ~<4>)  (cMul (cPow[x &]) <5> ~<6>) : (cMul (cPow[x (cMin % &)]) (cAdd (cMul <3> ~<4> (cPow[x (cAdd % ~(cMin % &))]))  (cMul <5> ~<6> (cPow[x (cAdd & ~(cMin % &))]))))
cAdd (cMul (cPow[x %]) <3> ~<4>)  (cMul x           <5> ~<6>) : (cMul (cPow[x (cMin % 1)]) (cAdd (cMul <3> ~<4> (cPow[x (cAdd % ~(cMin % 1))]))  (cMul <5> ~<6> (cPow[x (cAdd 1 ~(cMin % 1))]))))
cAdd (cMul (cPow[x %]) <3> ~<4>) ~(cMul (cPow[x &]) <5> ~<6>) : (cMul (cPow[x (cMin % &)]) (cAdd (cMul <3> ~<4> (cPow[x (cAdd % ~(cMin % &))])) ~(cMul <5> ~<6> (cPow[x (cAdd & ~(cMin % &))]))))
cAdd (cMul (cPow[x %]) <3> ~<4>) ~(cMul x           <5> ~<6>) : (cMul (cPow[x (cMin % 1)]) (cAdd (cMul <3> ~<4> (cPow[x (cAdd % ~(cMin % 1))])) ~(cMul <5> ~<6> (cPow[x (cAdd 1 ~(cMin % 1))]))))
cAdd (cMul x           <3> ~<4>) ~(cMul (cPow[x &]) <5> ~<6>) : (cMul (cPow[x (cMin 1 &)]) (cAdd (cMul <3> ~<4> (cPow[x (cAdd 1 ~(cMin 1 &))])) ~(cMul <5> ~<6> (cPow[x (cAdd & ~(cMin 1 &))]))))
# x^7 + x^4*y -> x^4*(x^(7-4) + x^(4-4)*y)
# x^4 + x^7*y -> x^4*(x^(4-4) + x^(7-4)*y)
# x^4 + x^5*y -> x^4*(1 + x*y) BETTER THAN
# x^4 + x^5*y -> x^5*(x^-1 + y)
# Generalized as:
# x^A + x^B*y -> x^MIN(A,B) * (x^(A-MIN(A,B)) + x^(B-MIN(A,B))*y)

#cAdd (cPow[x %]) (cMul (cPow[x +(% -1)]) <1> ~<2>) : (cMul (cPow[x (cMin % &)]) (cAdd (cPow[x (cAdd % ~(cMin % &))]) (cMul (cPow[x (cAdd & ~(cMin % &))]) <1> ~<2>)))



#### Remote double negations/inversions

# If an addlist contains a negated mul and that mul-list contains a factor,
# un-negate the mul-list and negate the factor in the mul-list.
cAdd ~(cMul % <1> ~<2>)      : (cMul -% <1> ~<2>)

# If a mul-list contains the immed -1, remove
# the immed and wrap the rest in a negated cAdd.
# Note: This is not done to all negative immeds,
#       otherwise the rule above will revert it.
cMul -1 <1> ~<2>             -> cAdd ~(cMul <1> ~<2>)

# If an exponent is negated, negate it and wrap
# the rest in an inverted cMul.
cPow [ x (cAdd <1> ~<2> =-) ]       -> cMul ~(cPow [x (cAdd ~<1> <2>)])

# If a mul-list contains an inverted pow and the exponent is an immed,
# un-negate the pow and negate the immed.
cMul ~(cPow [x %])           : (cPow [x -%])

# (x^y)^z        -> x^(y*z)
cPow [ (cPow[x y]) z ]       : x (cMul [y z])


#### Constant folding:

# Negate literal negated params...
cAdd ~%      : -%
# Note: Don't invert literal inverted params liberally; doing so may lose precision.

# If a add-list contains two or more immeds, replace those immeds
# with a single non-negated immed that has the sum of those original
# immeds.
cAdd  %  &   : +(% &)

# If a mul-list contains two or more immeds, replace those immeds
# with a single non-inverted immed that has the product of those original
# immeds (paying attention to the polarity of those immeds)
cMul  %  &   : *(% &)
cMul  % ~&   : *(% /&)
# Note: To preserve precision, this is not done as *(/# /&).
cMul ~% ~&   : ~*(% &)

# If a min-list contains two or more immeds, replace those immeds
# with a single immed that is the minimum of the original immeds
cMin % &     : MIN(% &)

# If a max-list contains two or more immeds, replace those immeds
# with a single immed that is the maximum of the original immeds
cMax % &     : MAX(% &)

# Function call optimization with constant params
# such as sin(immed)->newimmed, log(immed)->newimmed etc.
cSin[%]      -> SIN(%)
cCos[%]      -> COS(%)
cTan[%]      -> TAN(%)
cAsin[%]     -> ASIN(%)
cAcos[%]     -> ACOS(%)
cAtan[%]     -> ATAN(%)
cSinh[%]     -> SINH(%)
cCosh[%]     -> COSH(%)
cTanh[%]     -> TANH(%)
cAsinh[%]    -> ASINH(%)
cAcosh[%]    -> ACOSH(%)
cAtanh[%]    -> ATANH(%)
cPow[% &]    -> POW(% &)
cCeil[%]     -> CEIL(%)
cFloor[%]    -> FLOOR(%)
cLog[%]      -> LOG(%)
cMod[% &]    -> MOD(% &)
# TODO: equal,nequal,less,lessoreq,greater,greatoreq,not,and,or


#### Logical optimizations

# Repetitions in and-lists don't help
cAnd  x x   : x
cAnd ~x ~x  : ~x
# Nor in or-lists
cOr   x  x  : x
cOr  ~x ~x  : ~x

# In an and-list, having x and !x invalides the whole list
cAnd x ~x   -> 0

# In an or-list, having x and !x validates the whole list
cOr x ~x    -> 1

# Eschew so many negations.
#   !a & !b = !(a | b)
cAnd <1> ~<2> =- : ~(cOr <2> ~<1>)
#   !a | !b = !(a & b)
cOr <1> ~<2> =- : ~(cAnd <2> ~<1>)

cAnd ~(cNEqual[a b])      : (cEqual[a b])
cAnd ~(cEqual[a b])       : (cNEqual[a b])
cAnd ~(cLess[a b])        : (cGreaterOrEq[a b])
cAnd ~(cGreater[a b])     : (cLessOrEq[a b])
cAnd ~(cLessOrEq[a b])    : (cGreater[a b])
cAnd ~(cGreaterOrEq[a b]) : (cLess[a b])
cOr ~(cNEqual[a b])       : (cEqual[a b])
cOr ~(cEqual[a b])        : (cNEqual[a b])
cOr ~(cLess[a b])         : (cGreaterOrEq[a b])
cOr ~(cGreater[a b])      : (cLessOrEq[a b])
cOr ~(cLessOrEq[a b])     : (cGreater[a b])
cOr ~(cGreaterOrEq[a b])  : (cLess[a b])
cNot [(cNEqual[a b])]      -> cEqual[a b]
cNot [(cEqual[a b])]       -> cNEqual[a b]
cNot [(cLess[a b])]        -> cGreaterOrEq[a b]
cNot [(cGreater[a b])]     -> cLessOrEq[a b]
cNot [(cLessOrEq[a b])]    -> cGreater[a b]
cNot [(cGreaterOrEq[a b])] -> cLess[a b]
cNotNot [(cNEqual[a b])]      -> cNEqual[a b]
cNotNot [(cEqual[a b])]       -> cEqual[a b]
cNotNot [(cLess[a b])]        -> cLess[a b]
cNotNot [(cGreater[a b])]     -> cGreater[a b]
cNotNot [(cLessOrEq[a b])]    -> cLessOrEq[a b]
cNotNot [(cGreaterOrEq[a b])] -> cGreaterOrEq[a b]
cNotNot [(cAnd <1> ~<2>)]     -> cAnd <1> ~<2>
cNotNot [(cOr  <1> ~<2>)]     -> cOr  <1> ~<2>

# From logic, follows that...
#   (a==b) & (b==c) & (a==c) -- one of these is redundant
cAnd (cEqual a b) (cEqual b c) (cEqual a c)  : (cEqual [a b]) (cEqual [b c])
#   (a==b) & (a!=b)          -- this statement is always false
cAnd (cEqual a b) (cNEqual a b) -> 0
#   (a==b) | (a!=b)          -- this statement is always true
cOr  (cEqual a b) (cNEqual a b) -> 1

#   x==x -- this statement is always true (note: might be not when we have NaN, but we don't care)
cEqual[x x]                     -> 1
cLessOrEq[x x]                  -> 1
cGreaterOrEq[x x]               -> 1
#   x!=x -- this statement is always false (note: we ignore NaN cases)
cNEqual[x x]                    -> 0
cLess[x x]                      -> 0
cGreater[x x]                   -> 0



#### Logarithm optimizations
# log(pow(X,Y))/log(X) = Y

cMul  (cLog[(cPow [x y])]) ~(cLog[x])  : y
cMul ~(cLog[(cPow [x y])])  (cLog[x])  : ~y

cMul  (cLog[(cPow [% y])]) ~LOG(%)  : y
cMul  (cLog[(cPow [% y])]) /LOG(%)  : y
cMul ~(cLog[(cPow [% y])])  LOG(%)  : ~y

# CONSTANT_E^log(x) = x
cPow [CONSTANT_E (cLog[x])]   -> x

# CONSTANT_E^(log(x)*y) = x^y
cPow [CONSTANT_E (cMul (cLog[x]) <1> ~<2>)]   : x (cMul <1> ~<2>)

# z^(log(x)/log(z)*y) = x^y
cPow [z (cMul ~(cLog[z]) (cLog[x]) <1> ~<2>)] : x (cMul <1> ~<2>)
cPow [% (cMul ~LOG(%)    (cLog[x]) <1> ~<2>)] : x (cMul <1> ~<2>)
cPow [% (cMul /LOG(%)    (cLog[x]) <1> ~<2>)] : x (cMul <1> ~<2>)

# log(x^z) = z * log(x)
cLog [(cPow [x z])] -> cMul [z (cLog [x])]

# log(x) + log(y) + log(z) = log(x*y*z)
cAdd (cLog[x]) (cLog[y]) : (cLog (cMul x y))

# log(x * CONSTANT_E^y) = log(x) + y
cLog [(cMul (cPow [CONSTANT_E y]) <1> ~<2>)] -> cAdd [(cLog [(cMul <1> ~<2>)]) y]

# log(x * z^y) / log(z) = log(x) / log(z) + y
# Note: z can also be an immed
cMul (cLog [(cMul x (cPow [z y]))]) ~(cLog[z])  -> cAdd [(cMul [(cLog [x]) ~(cLog [z])]) y]
cMul (cLog [(cMul x (cPow [% y]))]) ~LOG(%)     -> cAdd [(cMul [(cLog [x]) /LOG(%)]) y]
cMul (cLog [(cMul x (cPow [% y]))]) /LOG(%)     -> cAdd [(cMul [(cLog [x]) /LOG(%)]) y]


#### Trigonometric:
# sin(x)/cos(x) = tan(x)
cMul  (cSin[x]) ~(cCos[x]) :  (cTan[x])
cMul ~(cSin[x])  (cCos[x]) : ~(cTan[x])
cMul  (cSinh[x]) ~(cCosh[x]) :  (cTanh[x])
cMul ~(cSinh[x])  (cCosh[x]) : ~(cTanh[x])

# sin(-x) = -sin(x)
cSin [(cAdd [~x])] -> cAdd ~(cSin [x])
# tan(-x) = -tan(x)
cTan [(cAdd [~x])] -> cAdd ~(cTan [x])
# cos(-x) = cos(x)
cCos [(cAdd [~x])] : x

# sinh(-x) = -sinh(x)
cSinh [(cAdd [~x])] -> cAdd [~(cSinh [x])]
# cosh(-x) = cosh(x)
cCosh [(cAdd [~x])] : x

# sinh(x)*2 = (exp(x)-  exp(-x))
# sinh(x)*2 = (exp(x)-1/exp(x))
# cosh(x)*2 = (exp(x)+  exp(-x))
# cosh(x)*2 = (exp(x)+1/exp(x))
cAdd (cPow [CONSTANT_E x]) ~(cMul [~(cPow [CONSTANT_E x])]) : (cMul (cSinh [x]) 2)
cAdd (cPow [CONSTANT_E x])  (cMul [~(cPow [CONSTANT_E x])]) : (cMul (cCosh [x]) 2)

# Because sinh(-x) = -sinh(x),
# sinh(x)*-2 = (exp(-x)-exp(x))
cAdd ~(cPow [CONSTANT_E x]) (cMul [~(cPow [CONSTANT_E x])]) : (cMul (cSinh [x]) -2)

# exp(x)  = cosh(x)+sinh(x)
# exp(-x) = cosh(x)-sinh(x)
cAdd  (cCosh [x])  (cSinh [x]) : (cPow [CONSTANT_E x])
cAdd  (cCosh [x]) ~(cSinh [x]) : (cMul [~(cPow [CONSTANT_E x])])
cAdd ~(cCosh [x]) ~(cSinh [x]) : ~(cPow [CONSTANT_E x])
cAdd ~(cCosh [x])  (cSinh [x]) : ~(cMul [~(cPow [CONSTANT_E x])])
cAdd  (cCosh [x]) ~(cPow [CONSTANT_E x]) : (cSinh [x])
cAdd  (cSinh [x]) ~(cPow [CONSTANT_E x]) : (cCosh [x])
cAdd ~(cCosh [x])  (cPow [CONSTANT_E x]) : ~(cSinh [x])
cAdd ~(cSinh [x])  (cPow [CONSTANT_E x]) : ~(cCosh [x])

# sinh(acosh(x)) = sqrt(x^2 - 1)  (not a typo)
# cosh(asinh(x)) = sqrt(x^2 + 1)  (not a typo)
#  Not sure whether these are faster. They are more opcodes, but
#  simpler. The rationale is in allowing for further optimizations.
cSinh [(cAcosh [x])] -> cPow [(cAdd [(cPow [x 2]) -1]) 0.5]
cCosh [(cAsinh [x])] -> cPow [(cAdd [(cPow [x 2])  1]) 0.5]


# cos(pi/2 - x) = sin(x)
cCos [(cAdd CONSTANT_PIHALF x)] -> cSin[x]
# sin(pi/2 - x) = cos(x)
cSin [(cAdd CONSTANT_PIHALF x)] -> cCos[x]
# cot(pi/2 - x) = 1/tan(pi/2 - x) = tan(x)
cMul [~(cTan [(cAdd CONSTANT_PIHALF x)])] -> cTan[x]

# sin(x)^2 + cos(x)^2 = 1
cAdd  (cPow[ (cSin[x]) 2]) (cPow [(cCos[x]) 2]) : 1
# y-sin(x)^2 = cos(x)^2+(y-1)
# y-cos(x)^2 = sin(x)^2+(y-1)
cAdd 1 ~(cPow[ (cSin[x]) 2]) : (cPow [(cCos[x]) 2])
cAdd 1 ~(cPow[ (cCos[x]) 2]) : (cPow [(cSin[x]) 2])

# sin(x)*cos(y) + cos(x)*sin(y) = sin(x+y)
# sin(x)*cos(y) - cos(x)*sin(y) = sin(x-y)
# cos(x)*cos(y) + sin(x)*sin(y) = cos(x+y)
# cos(x)*cos(y) - sin(x)*sin(y) = cos(x-y)

cAdd  (cMul {(cSin[x]) (cCos[y])})  (cMul {(cCos[x]) (cSin[y])}) :  (cSin (cAdd[x  y]))
cAdd  (cMul {(cSin[x]) (cCos[y])}) ~(cMul {(cCos[x]) (cSin[y])}) :  (cSin (cAdd[x ~y]))
cAdd  (cMul {(cCos[x]) (cCos[y])})  (cMul {(cSin[x]) (cSin[y])}) :  (cCos (cAdd[x  y]))
cAdd  (cMul {(cCos[x]) (cCos[y])}) ~(cMul {(cSin[x]) (cSin[y])}) :  (cCos (cAdd[x ~y]))

cAdd ~(cMul {(cSin[x]) (cCos[y])}) ~(cMul {(cCos[x]) (cSin[y])}) : ~(cSin (cAdd[x  y]))
cAdd ~(cMul {(cCos[x]) (cCos[y])}) ~(cMul {(cSin[x]) (cSin[y])}) : ~(cCos (cAdd[x  y]))
cAdd ~(cMul {(cCos[x]) (cCos[y])})  (cMul {(cSin[x]) (cSin[y])}) : ~(cCos (cAdd[x ~y]))
# This one is redudant: It just reaffirms that sin(x) = -sin(-x).
#cAdd ~(cMul {(cSin[x]) (cCos[y])})  (cMul {(cCos[x]) (cSin[y])}) : ~(cSin (cAdd[x ~y]))


#### Self-defeating function calls:
# sin(asin(x)) = x
cSin [(cAsin [x])] -> x

# cos(acos(x)) = x
cCos [(cAcos [x])] -> x

# tan(atan(x)) = x
cTan [(cAtan [x])] -> x

# Note: asin(sin(x)) must not be converted, because
# even though asin(sin(1.1)) = 1.1, asin(sin(1500)) != 1500.

cAbs [(cNeg [x])] : x

# TODO: abs sqr -> sqr, sqr abs -> sqr, sqrt abs -> sqrt, sqrt abs sqr -> ""


[FINAL]
# These optimizations are done only once, after the intermediate conversions.
# This process generates optimized opcodes that are not expected to be found
# in the intermediate stage.
#
# Do not generate cDiv, cRDiv, cInv, cSub, cRSub, cNeg or cNot here.
# Those are done in the bytecode generation automatically.
#

# x * CONSTANT_DR = cDeg(x)
# x * ~CONSTANT_RD = cDeg(x)
cMul  CONSTANT_DR <1> ~<2> -> cDeg [(cMul <1> ~<2>)]
# Note: This may produce one-operand cMul lists.
# Those are treated properly in the bytecode generation,
# and do not need to be handled by [INTERMEDIATE].

# x * CONSTANT_RD = cRad(x)
# x * ~CONSTANT_DR = cRad(x)
cMul  CONSTANT_RD <1> ~<2> -> cRad [(cMul <1> ~<2>)]

# x^0.5 = sqrt(x)
cPow [x 0.5]         -> cSqrt [x]

# x^-0.5 = rsqrt(x)
cPow [x -0.5]        -> cRSqrt [x]

# pow(CONSTANT_E, x) = exp(x)
cPow [CONSTANT_E x]  -> cExp [x]

# log(x) / CONSTANT_L10  = log10(x)
cMul  (cLog [x]) CONSTANT_L10I  :  (cLog10 [x])
cMul ~(cLog [x])   CONSTANT_L10 : ~(cLog10 [x])

# log(x) / CONSTANT_L2 = log2(x)
cMul  (cLog [x]) CONSTANT_L2I  :  (cLog2 [x])
cMul ~(cLog [x])   CONSTANT_L2 : ~(cLog2 [x])

# In a mul-list, ~sin(x) = csc(x)
cMul ~(cSin [x])      : (cCsc [x])

# In a mul-list, ~cos(x) = sec(x)
cMul ~(cCos [x])      : (cSec [x])

# In a mul-list, ~tan(x) = cot(x)
cMul ~(cTan [x])      : (cCot [x])

# These should not occur after [INTERMEDIATE]
#cMul x x              :  (cSqr[x])
#cMul ~x ~x            : ~(cSqr[x])

# Do not reduce add/mul/min/max/and/or lists to two-operand topology
# Those are done in the bytecode generation automatically.

# Unprotect not-not
cNotNot[x]     -> cNot [(cNot [x])]
