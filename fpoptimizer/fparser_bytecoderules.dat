# This documents all the optimizations that are done to bytecode
# by fparser.cc directly while parsing the input function
# (excluding powi).

# identifiers: lowercase=cImmeds, uppercase=opcodes
# [bracketed expression in condition]: constraints to input immeds or opcodes
# [bracketed expression in replacement]: function that produces an immed
# {braceted expression in replacement}: function that produces an opcode

#y [isEvenInteger(y)&&!isEvenInteger(x*y)] cExp  x cPow -> cAbs [y*x] cExp
#y [isEvenInteger(y)&&!isEvenInteger(x*y)] cExp2 x cPow -> cAbs [y*x] cExp2
#  ^ y cExp never occurs (already optimized to literal)
IF(FP_FLOAT_VERSION) y [isEvenInteger(y)&&!isEvenInteger(x*y)] cPow  x cPow -> cAbs [y*x] cPow
IF(FP_FLOAT_VERSION) cSqr x [!isEvenInteger(x+x)] cPow -> cAbs [x+x] cPow
IF(FP_FLOAT_VERSION) cSqr cSqrt  -> cAbs
#IF(FP_FLOAT_VERSION) cSqr cRSqrt -> cAbs cInv

 # (x^y)^1.5  is unacceptable,
 #            for y might be 2, resulting in x^3
 #              f(-2)  = 8
 #              f'(-2) = -8
 # (x^y)^5    is okay
 #            for y might be 1.2, reuslting in x^6
 #              f(-2) = nan
 #              f'(-2) = 64
 # (x^y)^2    is okay,
 #            for y might be 1.5, resulting in x^3
 #              f(-2) = nan  <- ok because of this
 #              f'(-2) = -8
 #
#y [!IsIntegerConst(y)] cExp  x	[IsIntegerConst(x)] cPow -> [y*x] cExp
#y [!IsIntegerConst(y)] cExp2 x	[IsIntegerConst(x)] cPow -> [y*x] cExp2
#  ^ y cExp never occurs (already optimized to literal)
IF(FP_FLOAT_VERSION) y [!IsIntegerConst(y)] cPow  x	[IsIntegerConst(x)] cPow -> [y*x] cPow
IF(FP_FLOAT_VERSION) cExp  x	[IsIntegerConst(x)] cPow -> [x] cMul cExp
IF(FP_FLOAT_VERSION) cExp2 x	[IsIntegerConst(x)] cPow -> [x] cMul cExp2
IF(FP_FLOAT_VERSION) cPow  x	[IsIntegerConst(x)] cPow -> [x] cMul cPow
IF(FP_FLOAT_VERSION) cSqr x cPow -> [x+x] cPow

x cAbs	 		-> [fp_abs(x)]
IF(FP_FLOAT_VERSION) x [x>=Value_t(1)]                 cAcosh -> [fp_acosh(x)]
IF(FP_FLOAT_VERSION) x                                 cAsinh -> [fp_asinh(x)]
IF(FP_FLOAT_VERSION) x [x> Value_t(-1)&&x< Value_t(1)] cAtanh -> [fp_atanh(x)]
IF(FP_FLOAT_VERSION) x [x>=Value_t(-1)&&x<=Value_t(1)] cAcos -> [fp_acos(x)]
IF(FP_FLOAT_VERSION) x [x>=Value_t(-1)&&x<=Value_t(1)] cAsin -> [fp_asin(x)]
IF(FP_FLOAT_VERSION) x cAtan	 		-> [fp_atan(x)]
IF(FP_FLOAT_VERSION) x cCbrt	 		-> [fp_cbrt(x)]
IF(FP_FLOAT_VERSION) x cCeil	 		-> [fp_ceil(x)]
IF(FP_FLOAT_VERSION) x cCos	 		-> [fp_cos(x)]
IF(FP_FLOAT_VERSION) x cCosh	 		-> [fp_cosh(x)]
IF(FP_FLOAT_VERSION) x cExp	 		-> [fp_exp(x)]
IF(FP_FLOAT_VERSION) x cExp2	 		-> [fp_exp2(x)]
IF(FP_FLOAT_VERSION) x cFloor 			-> [fp_floor(x)]
IF(FP_FLOAT_VERSION) x cInt	 		-> [fp_int(x)]
IF(FP_FLOAT_VERSION) x [x> Value_t(0)] cLog	-> [fp_log(x)]
IF(FP_FLOAT_VERSION) x [x> Value_t(0)] cLog10	-> [fp_log10(x)]
IF(FP_FLOAT_VERSION) x [x> Value_t(0)] cLog2	-> [fp_log2(x)]
IF(FP_FLOAT_VERSION) x cSin	 		-> [fp_sin(x)]
IF(FP_FLOAT_VERSION) x cSinh	 		-> [fp_sinh(x)]
IF(FP_FLOAT_VERSION) x [x>=Value_t(0)] cSqrt	-> [fp_sqrt(x)]
#IF(FP_FLOAT_VERSION) x [x> Value_t(0)] cRSqrt	-> [Value_t(1)/fp_sqrt(x)]
IF(FP_FLOAT_VERSION) x cTan	 		-> [fp_tan(x)]
IF(FP_FLOAT_VERSION) x cTanh	 		-> [fp_tanh(x)]
IF(FP_FLOAT_VERSION) x cTrunc 			-> [fp_trunc(x)]
IF(FP_FLOAT_VERSION) x cDeg	 		-> [RadiansToDegrees(x)]
IF(FP_FLOAT_VERSION) x cRad	 		-> [DegreesToRadians(x)]
cSqrt cInv -> cRSqrt
x cNeg			-> [-x]
x [x!=Value_t(0)] cInv 	-> [Value_t(1)/x]
x [x==Value_t(1)] cMul	->
y x cMul		-> [y*x]
x [x==Value_t(1)] cDiv	->
y x [x!=Value_t(0)] cDiv -> [y/x]
y x [x!=Value_t(0)] cMod -> [fp_mod(y,x)]
x [x==Value_t(0)] cAdd	->
y x cAdd		-> [y+x]
x [x==Value_t(0)] cSub	->
y x cSub		-> [y-x]
#y [y!=Value_t(0)] x cRDiv -> [x/y]
#y x cRSub		-> [x-y]
y x cMin		-> [Min(x,y)]
y x cMax		-> [Max(x,y)]
IF(FP_FLOAT_VERSION) y x cAtan2		-> [fp_atan2(y,x)]
IF(FP_FLOAT_VERSION) y [ y!=Value_t(0) || x>=Value_t(0)] x cPow -> [fp_pow(y,x)]
x cNot			-> [!truthValue(x)]

# Multiplications by zero: Undo as many operands as possible by peeling.
# Some of these optimimizations can be disabled due to law of diminishing returns.
A [A >= VarBegin]                                                                                       x [x==Value_t(0)] cMul ->        [x]
                                                 A [IsUnaryOpcode(A)&&!HasInvalidRangesOpcode(A)]       x [x==Value_t(0)] cMul ->        [x] cMul
B [B >= VarBegin]                                A [IsBinaryOpcode(A)&&!HasInvalidRangesOpcode(A)]      x [x==Value_t(0)] cMul ->        [x] cMul
B [IsUnaryOpcode(B)&&!HasInvalidRangesOpcode(B)] A [IsBinaryOpcode(A)&&!HasInvalidRangesOpcode(A)]      x [x==Value_t(0)] cMul -> A      [x] cMul
y                                                A [IsBinaryOpcode(A)&&!HasInvalidRangesOpcode(A)]      x [x==Value_t(0)] cMul ->        [x] cMul
A [A >= VarBegin]                                                                                  cMul x [x==Value_t(0)] cMul ->        [x] cMul
C [C >= VarBegin]                                B [IsBinaryOpcode(B)&&!HasInvalidRangesOpcode(B)] A[IsBinaryOpcode(A)&&!HasInvalidRangesOpcode(A)] x [x==Value_t(0)] cMul ->   A [x] cMul
C [IsUnaryOpcode(C)&&!HasInvalidRangesOpcode(C)] B [IsBinaryOpcode(B)&&!HasInvalidRangesOpcode(B)] A[IsBinaryOpcode(A)&&!HasInvalidRangesOpcode(A)] x [x==Value_t(0)] cMul -> B A [x] cMul
y                                                B [IsBinaryOpcode(B)&&!HasInvalidRangesOpcode(B)] A[IsBinaryOpcode(A)&&!HasInvalidRangesOpcode(A)] x [x==Value_t(0)] cMul ->   A [x] cMul


x [x==Value_t(2)] cMul -> cDup cAdd
IF(FP_FLOAT_VERSION) x [x==GetRadiansToDegreesFactor<Value_t>()] cMul -> cDeg
IF(FP_FLOAT_VERSION) x [x==GetDegreesToRadiansFactor<Value_t>()] cMul -> cRad
IF(FP_FLOAT_VERSION) cSqr cLog   -> cAbs cLog   cDup cAdd
IF(FP_FLOAT_VERSION) cSqr cLog2  -> cAbs cLog2  cDup cAdd
IF(FP_FLOAT_VERSION) cSqr cLog10 -> cAbs cLog10 cDup cAdd
IF(FP_FLOAT_VERSION) cDeg x cMul -> [RadiansToDegrees(x)] cMul
IF(FP_FLOAT_VERSION) cRad x cMul -> [DegreesToRadians(x)] cMul
cDup cAdd cDup cAdd -> [Value_t(4)] cMul

cDup cMin ->
cDup cMax ->
B [B==A] cDup A [A >= VarBegin] cMin -> B cDup
B [B==A] cDup A [A >= VarBegin] cMax -> B cDup
B [B==A] cMin A [A >= VarBegin] cMin -> B cMin
B [B==A] cMax A [A >= VarBegin] cMax -> B cMax

# x/x = 1. Since we cannot easily replace x with 1
# without handling all kinds of lengths for lhs,
# multiply it with 0 instead (this will invoke the
# operand peeler), and then add 1.
cDup cDiv              -> [Value_t(0)] cMul [Value_t(1)] cAdd
# Exactly the same here, with x^0, however cPow is float-only:
IF(FP_FLOAT_VERSION) x [x==Value_t(0)] cPow -> [Value_t(0)] cMul [Value_t(1)] cAdd

y x cLess		-> [fp_less(y,x)]
y x cLessOrEq		-> [fp_lessOrEq(y,x)]
y x cGreater		-> [fp_less(x,y)]
y x cGreaterOrEq	-> [fp_lessOrEq(x,y)]
y x cEqual		-> [fp_equal(y,x)]
y x cNEqual		-> [fp_nequal(y,x)]
y x cAnd		-> [truthValue(x)&&truthValue(y)]
y x cOr			-> [truthValue(x)||truthValue(y)]
#y x cAbsAnd		-> [truthValue_abs(x)&&truthValue_abs(y)]
#y x cAbsOr		-> [truthValue_abs(x)||truthValue_abs(y)]

cNeg x cMul		-> [-x] cMul
x cMul cNeg		-> [-x] cMul
x [x==Value_t(-1)] cMul		-> cNeg
cNeg x [x!=Value_t(0)] cDiv	-> [-x] cDiv


y cAdd x cAdd		-> [y+x] cAdd

IF(FP_FLOAT_VERSION) y [(y*x)==GetRadiansToDegreesFactor<Value_t>()] cMul x cMul -> cDeg
IF(FP_FLOAT_VERSION) y [(y*x)==GetDegreesToRadiansFactor<Value_t>()] cMul x cMul -> cRad
y [y*x==Value_t(1)] cMul x cMul ->
y                   cMul x cMul -> [y*x] cMul
cDup [x+x==Value_t(1)] cAdd x cMul ->
cDup                   cAdd x cMul -> [x+x] cMul

IF(FP_FLOAT_VERSION) y [(y/x)==GetRadiansToDegreesFactor<Value_t>()] cMul x [x!=Value_t(0)] cDiv -> cDeg
IF(FP_FLOAT_VERSION) y [(y/x)==GetDegreesToRadiansFactor<Value_t>()] cMul x [x!=Value_t(0)] cDiv -> cRad
IF(FP_FLOAT_VERSION) y cMul x [x!=Value_t(0)] cDiv 	-> [y/x] cMul

IF(FP_FLOAT_VERSION) x [x!=Value_t(0)] cDiv		-> [Value_t(1)/x] cMul

# This rule does not speed up evaluation at all, but
# it greatly simplifies the optimization rule set, when
# we don't need to check for sequences of an immed and cSub.
x cSub -> [-x] cAdd

#IF(FP_FLOAT_VERSION) y cExp  x cPow -> [y*x] cExp
#IF(FP_FLOAT_VERSION) y cExp2 x cPow -> [y*x] cExp2
#  ^ y cExp never occurs (already optimized to literal)
IF(FP_FLOAT_VERSION) y cPow  x cPow -> [y*x] cPow

IF(FP_FLOAT_VERSION) x [x==Value_t(0.5)]      cPow -> cSqrt
IF(FP_FLOAT_VERSION) x [x==Value_t(1)/Value_t(3)]  cPow -> cCbrt
IF(FP_FLOAT_VERSION) x [x==Value_t(1)/Value_t(-3)] cPow -> cCbrt cInv
IF(FP_FLOAT_VERSION) x [x==Value_t(-0.5)]     cPow -> cRSqrt
IF(FP_FLOAT_VERSION) x [x==Value_t(-1)]     cPow -> cInv

IF(FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] cSqrt cSqr  -> A
# ^ Doable only if lhs > 0.
IF(FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] cLog  cExp  -> A
IF(FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] cLog2 cExp2 -> A
# ^ Doable only if lhs > 0.
IF(FP_FLOAT_VERSION) cExp  cLog  ->
IF(FP_FLOAT_VERSION) cExp2 cLog2 ->
#IF(FP_FLOAT_VERSION) cAsin cSin ->
#IF(FP_FLOAT_VERSION) cAcos cCos ->
# ^ Doable only if abs(x) <= 1
#IF(FP_FLOAT_VERSION) cAtan cTan ->
IF(FP_FLOAT_VERSION) cAsinh cSinh ->
IF(FP_FLOAT_VERSION) cAcosh cCosh ->
#IF(FP_FLOAT_VERSION) cAtanh cTanh ->
# ^ Doable only if abs(x) < 1
IF(FP_FLOAT_VERSION) cAtan2 cTan -> cDiv
cNeg  cAbs -> cAbs
cInv  cInv ->
cNeg  cNeg ->
IF(FP_FLOAT_VERSION) cPow  cInv -> cNeg cPow

IF(FP_FLOAT_VERSION) cInv cDiv -> cMul
cInv cMul -> cDiv
cNeg cAdd -> cSub
cNeg cSub -> cAdd

#IF(FP_FLOAT_VERSION) x [x<0] cPow cMul -> [-x] cPow cDiv

cLess        cNot -> cGreaterOrEq
cLessOrEq    cNot -> cGreater
cGreater     cNot -> cLessOrEq
cGreaterOrEq cNot -> cLess
cEqual       cNot -> cNEqual
cNEqual      cNot -> cEqual

cAbs x [x==Value_t(0)] cEqual  -> [x] cEqual
cAbs x [x==Value_t(0)] cNEqual -> [x] cNEqual
cSqr x [x==Value_t(0)] cEqual  -> [x] cEqual
cSqr x [x==Value_t(0)] cNEqual -> [x] cNEqual

                     y                 cAdd x A [IsComparisonOpcode(A)] -> [x-y] A
                                       cNeg x A [IsComparisonOpcode(A)] -> [-x] {OppositeComparisonOpcode(A)}
IF(FP_FLOAT_VERSION) y [y>Value_t(0)]  cMul x A [IsComparisonOpcode(A)] -> [x/y] A
IF(FP_FLOAT_VERSION) y [y<Value_t(0)]  cMul x A [IsComparisonOpcode(A)] -> [x/y] {OppositeComparisonOpcode(A)}
IF(FP_FLOAT_VERSION) y [y>Value_t(0)]  cPow [x>Value_t(0)] x A [IsComparisonOpcode(A)] -> [fp_pow(x,1/y)] A
IF(FP_FLOAT_VERSION)                   cSqr [x>Value_t(0)] x A [IsComparisonOpcode(A)] -> cAbs [fp_sqrt(x)] A


cNeg  cNot -> cNot
cAbs  cNot -> cNot
cNot  cNot -> cNotNot
cNotNot cNot    -> cNot
cAbsNotNot cNot -> cAbsNot

A [IsLogicalOpcode(A)]            cAbsNot cNot -> A
A [A!=cImmed]                     cAbsNot cNot -> A cAbsNotNot
A [IsNeverNegativeValueOpcode(A)] cNot -> A cAbsNot

A [IsNeverNegativeValueOpcode(A)] cAbs   -> A
IF(FP_FLOAT_VERSION) A [IsAlwaysIntegerOpcode(A)]	  cTrunc-> A
IF(FP_FLOAT_VERSION) A [IsAlwaysIntegerOpcode(A)]	  cFloor-> A
IF(FP_FLOAT_VERSION) A [IsAlwaysIntegerOpcode(A)]	  cCeil -> A
IF(FP_FLOAT_VERSION) A [IsAlwaysIntegerOpcode(A)]	  cInt  -> A

#IF(FP_FLOAT_VERSION) x cMul cFloor cNeg -> [-x] cMul cCeil
#IF(FP_FLOAT_VERSION) x cMul cCeil  cNeg -> [-x] cMul cFloor
IF(FP_FLOAT_VERSION) cNeg cFloor -> cCeil cNeg
IF(FP_FLOAT_VERSION) cNeg cCeil  -> cFloor cNeg

IF(FP_FLOAT_VERSION) x cAdd cExp  -> cExp  [fp_exp(x)]     cMul
IF(FP_FLOAT_VERSION) x cAdd cExp2 -> cExp2 [fp_exp2(x)] cMul

IF(FP_FLOAT_VERSION) cPow  cDiv -> cNeg cPow  cMul
IF(FP_FLOAT_VERSION) cExp  cDiv -> cNeg cExp  cMul
IF(FP_FLOAT_VERSION) cExp2 cDiv -> cNeg cExp2 cMul

IF(!FP_FLOAT_VERSION) x [x==Value_t(0)] cEqual  -> cNot
IF(!FP_FLOAT_VERSION) x [x==Value_t(0)] cNEqual -> cNotNot
IF(!FP_FLOAT_VERSION) cAbs x [x==Value_t(0)] cGreater     -> cNotNot
IF(!FP_FLOAT_VERSION) cAbs x [x==Value_t(1)] cGreaterOrEq -> cNotNot
IF(!FP_FLOAT_VERSION) cAbs x [x==Value_t(1)] cLess     -> cNot
IF(!FP_FLOAT_VERSION) cAbs x [x==Value_t(0)] cLessOrEq -> cNot
IF(!FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] x [x==Value_t(0)] cGreater     -> A cNotNot
IF(!FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] x [x==Value_t(1)] cGreaterOrEq -> A cNotNot
IF(!FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] x [x==Value_t(1)] cLess     -> A cNot
IF(!FP_FLOAT_VERSION) A [IsNeverNegativeValueOpcode(A)] x [x==Value_t(0)] cLessOrEq -> A cNot
IF(!FP_FLOAT_VERSION) A [IsLogicalOpcode(A)] x [x==Value_t(1)] cEqual  -> A
IF(!FP_FLOAT_VERSION) A [IsLogicalOpcode(A)] x [x==Value_t(1)] cNEqual -> A cNot

IF(FP_FLOAT_VERSION) cAbs x [x!=Value_t(0)] cLess         -> [Value_t(0.5)/x] cMul cNot
IF(FP_FLOAT_VERSION) cAbs x [x!=Value_t(0)] cGreaterOrEq  -> [Value_t(0.5)/x] cMul cNotNot

IF(FP_FLOAT_VERSION) cAbs      x [isEvenInteger(x)] cPow ->      [x] cPow
IF(FP_FLOAT_VERSION) cAbs cMul x [isEvenInteger(x)] cPow -> cMul [x] cPow

IF(FP_FLOAT_VERSION) cAbs cCos  -> cCos
IF(FP_FLOAT_VERSION) cAbs cCosh -> cCosh
IF(FP_FLOAT_VERSION) cNeg cCos  -> cCos
IF(FP_FLOAT_VERSION) cNeg cCosh -> cCosh
IF(FP_FLOAT_VERSION) cNeg cSin  -> cSin cNeg
IF(FP_FLOAT_VERSION) cNeg cSinh -> cSinh cNeg
IF(FP_FLOAT_VERSION) cNeg cTan  -> cTan cNeg
IF(FP_FLOAT_VERSION) cNeg cTanh -> cTanh cNeg
IF(FP_FLOAT_VERSION) x cMul cSin  cNeg -> [-x] cMul cSin
IF(FP_FLOAT_VERSION) x cMul cSinh cNeg -> [-x] cMul cSinh
IF(FP_FLOAT_VERSION) x cMul cTan  cNeg -> [-x] cMul cTan
IF(FP_FLOAT_VERSION) x cMul cTanh cNeg -> [-x] cMul cTanh

IF(FP_FLOAT_VERSION) cAcosh cSinh -> [DO_STACKPLUS1] cSqr [Value_t(-1)] cAdd cSqrt
IF(FP_FLOAT_VERSION) cAsinh cCosh -> [DO_STACKPLUS1] cSqr  [Value_t(1)] cAdd cSqrt

IF(FP_FLOAT_VERSION) cSin cDiv -> cCsc cMul
IF(FP_FLOAT_VERSION) cCos cDiv -> cSec cMul
IF(FP_FLOAT_VERSION) cTan cDiv -> cCot cMul
IF(FP_FLOAT_VERSION) cCsc cDiv -> cSin cMul
IF(FP_FLOAT_VERSION) cSec cDiv -> cCos cMul
IF(FP_FLOAT_VERSION) cCot cDiv -> cTan cMul
IF(FP_FLOAT_VERSION) cSin cInv -> cCsc
IF(FP_FLOAT_VERSION) cCos cInv -> cSec
IF(FP_FLOAT_VERSION) cTan cInv -> cCot
IF(FP_FLOAT_VERSION) cCsc cInv -> cSin
IF(FP_FLOAT_VERSION) cSec cInv -> cCos
IF(FP_FLOAT_VERSION) cCot cInv -> cTan

# Hardcoded optimizations that are too complex or
# impossible to convey using this rule file:
IF(FP_FLOAT_VERSION) x cPow -> [DO_POWI]

# x*x = x^2
B [B==A]           A [A >= VarBegin] cMul  -> B cSqr

# ...*x*x = ...*x^2
B [B==A]      cMul A [A >= VarBegin] cMul  -> B cSqr cMul

# -x*x = -(x^2)
B [B==A] cNeg      A [A >= VarBegin] cMul  -> B cSqr      cNeg

# x*-x = -(x^2)
B [B==A]      A [A >= VarBegin] cNeg cMul  -> B cSqr      cNeg

# ...*-x*x = ...*-(x^2)
B [B==A] cNeg cMul A [A >= VarBegin] cMul  -> B cSqr cMul cNeg

# ...*x*-x = ...*-(x^2)
B [B==A] cMul A [A >= VarBegin] cNeg cMul  -> B cSqr cMul cNeg

cNeg cSqr -> cSqr
cAbs cSqr -> cSqr

B [B==A] A [A >= VarBegin] -> B cDup
D [D==B] C [C==A]      B [B >= VarBegin] A [IsUnaryOpcode(A)]      -> D C cDup
D [D==B] C [C==A] cMul B [B >= VarBegin] A [IsUnaryOpcode(A)] cMul -> D C cSqr cMul
cDup cMul -> cSqr


IF(FP_FLOAT_VERSION) cExp2	 -> [DO_STACKPLUS1] [fp_log(Value_t(2))] cMul cExp
IF(FP_FLOAT_VERSION) cExp cLog2	 -> [DO_STACKPLUS1] [fp_log2(const_e<Value_t>())] cMul
IF(FP_FLOAT_VERSION) cExp cLog10 -> [DO_STACKPLUS1] [fp_log10(const_e<Value_t>())] cMul

#    expr0 expr1 cExp cMul cLog
# -> expr0 cLog expr1 cAdd
# could be done if expr1 is a var. Too special case. Not doing...
#    expr0 cLog expr1 cLog
# -> expr0 expr1 cMul cLog
# similar.

IF(FP_FLOAT_VERSION) x [x>Value_t(0)] cMul cLog2  -> cLog2  [fp_log2(x)]  cAdd
IF(FP_FLOAT_VERSION) x [x>Value_t(0)] cMul cLog   -> cLog   [fp_log(x)]   cAdd
IF(FP_FLOAT_VERSION) x [x>Value_t(0)] cMul cLog10 -> cLog10 [fp_log10(x)] cAdd
