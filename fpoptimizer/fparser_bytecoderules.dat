# This documents all the optimizations that are done to bytecode
# by fparser.cc directly while parsing the input function
# (excluding powi).
#
# The idea is to generate automatically the optimizations from
# this file, but we are not there yet.
#

# identifiers: lowercase=cImmeds, uppercase=opcodes
# [bracketed expression in condition]: constraints to input immeds or opcodes
# [bracketed expression in replacement]: function that produces an immed

#y [isEvenInteger(y)&&!isEvenInteger(x*y)] cExp  x cPow -> cAbs [y*x] cExp
#y [isEvenInteger(y)&&!isEvenInteger(x*y)] cExp2 x cPow -> cAbs [y*x] cExp2
#  ^ y cExp never occurs (already optimized to literal)
y [isEvenInteger(y)&&!isEvenInteger(x*y)] cPow  x cPow -> cAbs [y*x] cPow
cSqr x [!isEvenInteger(x*Value_t(2))] cPow -> cAbs [x*Value_t(2)] cPow
cSqr cSqrt  -> IF(!FP_INT_VERSION) cAbs
#cSqr cRSqrt -> IF(!FP_INT_VERSION) cAbs cInv

 # (x^y)^1.5  is unacceptable,
 #            for y might be 2, resulting in x^3
 #              f(-2)  = 8
 #              f'(-2) = -8
 # (x^y)^5    is okay
 #            for y might be 1.2, reuslting in x^6
 #              f(-2) = nan
 #              f'(-2) = 64
 # (x^y)^2    is okay,
 #            for y might be 1.5, resulting in x^3
 #              f(-2) = nan  <- ok because of this
 #              f'(-2) = -8
 #
#y [!IsIntegerConst(y)] cExp  x	[IsIntegerConst(x)] cPow -> [y*x] cExp
#y [!IsIntegerConst(y)] cExp2 x	[IsIntegerConst(x)] cPow -> [y*x] cExp2
#  ^ y cExp never occurs (already optimized to literal)
y [!IsIntegerConst(y)] cPow  x	[IsIntegerConst(x)] cPow -> [y*x] cPow
cExp  x	[IsIntegerConst(x)] cPow -> IF(!FP_INT_VERSION) [x] cMul cExp
cExp2 x	[IsIntegerConst(x)] cPow -> IF(!FP_INT_VERSION) [x] cMul cExp2
cPow  x	[IsIntegerConst(x)] cPow -> [x] cMul cPow
cSqr x cPow -> [x*Value_t(2)] cPow

x cAbs	 		-> IF(!FP_INT_VERSION) [fp_abs(x)]
x cAcos	 		-> IF(!FP_INT_VERSION) [fp_acos(x)]
x [x>=Value_t(-1)&&x<=Value_t(1)] cAcosh -> IF(!FP_INT_VERSION) [fp_acosh(x)]
x [x>=Value_t(-1)&&x<=Value_t(1)] cAsinh -> IF(!FP_INT_VERSION) [fp_asinh(x)]
x cAtan	 		-> IF(!FP_INT_VERSION) [fp_atan(x)]
x cAtanh 		-> IF(!FP_INT_VERSION) [fp_atanh(x)]
x cCbrt	 		-> IF(!FP_INT_VERSION) [fp_cbrt(x)]
x cCeil	 		-> IF(!FP_INT_VERSION) [fp_ceil(x)]
x cCos	 		-> IF(!FP_INT_VERSION) [fp_cos(x)]
x cCosh	 		-> IF(!FP_INT_VERSION) [fp_cosh(x)]
x cExp	 		-> IF(!FP_INT_VERSION) [fp_exp(x)]
x cExp2	 		-> IF(!FP_INT_VERSION) [fp_exp2(x)]
x cFloor 		-> IF(!FP_INT_VERSION) [fp_floor(x)]
x cInt	 		-> IF(!FP_INT_VERSION) [fp_int(x)]
x [x>=Value_t(0)] cLog	-> IF(!FP_INT_VERSION) [fp_log(x)]
x [x>=Value_t(0)] cLog10 -> IF(!FP_INT_VERSION) [fp_log10(x)]
x [x>=Value_t(0)] cLog2	-> IF(!FP_INT_VERSION) [fp_log2(x)]
x cSin	 		-> IF(!FP_INT_VERSION) [fp_sin(x)]
x cSinh	 		-> IF(!FP_INT_VERSION) [fp_sinh(x)]
x [x>=Value_t(0)] cSqrt	-> IF(!FP_INT_VERSION) [fp_sqrt(x)]
x cTan	 		-> IF(!FP_INT_VERSION) [fp_tan(x)]
x cTanh	 		-> IF(!FP_INT_VERSION) [fp_tanh(x)]
x cTrunc 		-> IF(!FP_INT_VERSION) [fp_trunc(x)]
x cDeg	 		-> IF(!FP_INT_VERSION) [RadiansToDegrees(x)]
x cRad	 		-> IF(!FP_INT_VERSION) [DegreesToRadians(x)]
x cNeg			-> [-x]
x [x!=Value_t(0)] cInv 	-> [Value_t(1)/x]
x [x==Value_t(1)] cMul	->
y x cMul		-> [y*x]
x [x==Value_t(1)] cDiv	->
y x [x!=Value_t(0)] cDiv -> [y/x]
y x [x!=Value_t(0)] cMod -> [fp_mod(y,x)]
x [x==Value_t(0)] cAdd	->
y x cAdd		-> [y+x]
x [x==Value_t(0)] cSub	->
y x cSub		-> [y-x]
#y [y!=Value_t(0)] x cRDiv -> [x/y]
#y x cRSub		-> [x-y]
y x cMin		-> [Min(x,y)]
y x cMax		-> [Max(x,y)]
y x cAtan2		-> IF(!FP_INT_VERSION) [fp_atan2(y,x)]
y [ y!=Value_t(0) || x>=Value_t(0)] x cPow -> [fp_pow(y,x)]
x cNot			-> [!truthValue(x)]


A [A >= VarBegin] x [x==Value_t(0)] cMul -> [x]

x [x==Value_t(2)] cMul -> cDup cAdd
cSqr cLog   -> IF(!FP_INT_VERSION) cAbs cLog   cDup cAdd
cSqr cLog2  -> IF(!FP_INT_VERSION) cAbs cLog2  cDup cAdd
cSqr cLog10 -> IF(!FP_INT_VERSION) cAbs cLog10 cDup cAdd
cDup cAdd cDup cAdd -> [4] cMul


y x cLess		-> [fp_less(y,x)]
y x cLessOrEq		-> [fp_lessOrEq(y,x)]
y x cGreater		-> [fp_less(x,y)]
y x cGreaterOrEq	-> [fp_lessOrEq(x,y)]
y x cEqual		-> [fp_equal(y,x)]
y x cNEqual		-> [fp_nequal(y,x)]
y x cAnd		-> [truthValue(x)&&truthValue(y)]
y x cOr			-> [truthValue(x)||truthValue(y)]
#y x cAbsAnd		-> [truthValue_abs(x)&&truthValue_abs(y)]
#y x cAbsOr		-> [truthValue_abs(x)||truthValue_abs(y)]

cNeg x cMul		-> [-x] cMul
cNeg x cDiv		-> [-x] cDiv
x cMul cNeg		-> [-x] cMul
x [x==Value_t(-1)] cMul	-> cNeg


y cAdd x cAdd		-> [y+x] cAdd
y cSub x cAdd		-> [y-x] cSub
y cSub x cSub		-> [y+x] cSub
y cAdd x cSub		-> [y-x] cAdd

y cMul x cMul		-> [y*x] cMul
y cMul x [x!=Value_t(0)] cDiv 	-> [y*x] cMul

x [x!=Value_t(0)] cDiv		-> IF(!FP_INT_VERSION) [Value_t(1)/x] cMul

#y cExp  x cPow -> IF(!FP_INT_VERSION) [y*x] cExp
#y cExp2 x cPow -> IF(!FP_INT_VERSION) [y*x] cExp2
#  ^ y cExp never occurs (already optimized to literal)
y cPow  x cPow -> [y*x] cPow

x [x==Value_t(0.5)]      cPow -> IF(!FP_INT_VERSION) cSqrt
x [x==Value_t(1)/Value_t(3)]  cPow -> cCbrt
x [x==Value_t(1)/Value_t(-3)] cPow -> cCbrt cInv
x [x==Value_t(-0.5)]     cPow -> IF(!FP_INT_VERSION) cRSqrt
x [x==Value_t(-1)]     cPow -> cInv

cLog  cExp  -> IF(!FP_INT_VERSION)
cLog2 cExp2 -> IF(!FP_INT_VERSION)
cExp  cLog  -> IF(!FP_INT_VERSION)
cExp2 cLog2 -> IF(!FP_INT_VERSION)
cAsin cSin -> IF(!FP_INT_VERSION)
cAcos cCos -> IF(!FP_INT_VERSION)
cAtan cTan -> IF(!FP_INT_VERSION)
cAsinh cSinh -> IF(!FP_INT_VERSION)
cAcosh cCosh -> IF(!FP_INT_VERSION)
cAtanh cTanh -> IF(!FP_INT_VERSION)
cAtan2 cTan -> IF(!FP_INT_VERSION) cDiv
cNeg  cAbs -> cAbs
cInv  cInv ->
cNeg  cNeg ->
cPow  cInv -> cNeg cPow

cInv cDiv -> cMul
cInv cMul -> cDiv
cNeg cAdd -> cSub
cNeg cSub -> cAdd

x [x<0] cPow cMul -> [-x] cPow cDiv

cLess        cNot -> cGreaterOrEq
cLessOrEq    cNot -> cGreater
cGreater     cNot -> cLessOrEq
cGreaterOrEq cNot -> cLess
cEqual       cNot -> cNEqual
cNEqual      cNot -> cEqual

cNeg  cNot -> cNot
cAbs  cNot -> cNot
cNot  cNot -> cNotNot
cNotNot cNot    -> cNot
cAbsNotNot cNot -> cAbsNot

A [IsLogicalOpcode(A)]            cAbsNot cNot -> A
A                                 cAbsNot cNot -> A cAbsNotNot
A [IsNeverNegativeValueOpcode(A)] cNot -> A cAbsNot

A [IsNeverNegativeValueOpcode(A)] cAbs   -> A
A [IsAlwaysIntegerOpcode(A)]	  cTrunc-> IF(!FP_INT_VERSION) A
A [IsAlwaysIntegerOpcode(A)]	  cFloor-> IF(!FP_INT_VERSION) A
A [IsAlwaysIntegerOpcode(A)]	  cCeil -> IF(!FP_INT_VERSION) A
A [IsAlwaysIntegerOpcode(A)]	  cInt  -> IF(!FP_INT_VERSION) A

cFloor cNeg -> IF(!FP_INT_VERSION) cNeg cCeil
cCeil  cNeg -> IF(!FP_INT_VERSION) cNeg cFloor

x cAdd cExp  -> IF(!FP_INT_VERSION) cExp  [fp_exp(x)]     cMul
x cAdd cExp2 -> IF(!FP_INT_VERSION) cExp2 [fp_exp2(x)] cMul

x cMul cExp  cDiv -> IF(!FP_INT_VERSION) [-x] cMul cExp  cMul
x cMul cExp2 cDiv -> IF(!FP_INT_VERSION) [-x] cMul cExp2 cMul

cAbs x [x!=Value_t(0)] cLess         -> IF(!FP_INT_VERSION) [Value_t(0.5)/x] cMul cNot
cAbs x [x!=Value_t(0)] cGreaterOrEq  -> IF(!FP_INT_VERSION) [Value_t(0.5)/x] cMul cNotNot
A [IsNeverNegativeValueOpcode(A)] x [x==0] cLess -> A [x] cMul

cAbs      x [isEvenInteger(x)] cPow ->      [x] cPow
cAbs cMul x [isEvenInteger(x)] cPow -> cMul [x] cPow

cAbs cCos  -> IF(!FP_INT_VERSION) cCos
cAbs cCosh -> IF(!FP_INT_VERSION) cCosh
cNeg cCos  -> IF(!FP_INT_VERSION) cCos
cNeg cCosh -> IF(!FP_INT_VERSION) cCosh
cNeg cSin  -> IF(!FP_INT_VERSION) cSin cNeg
cNeg cSinh -> IF(!FP_INT_VERSION) cSinh cNeg
cNeg cTan  -> IF(!FP_INT_VERSION) cTan cNeg
cNeg cTanh -> IF(!FP_INT_VERSION) cTanh cNeg
x cMul cSin  cNeg -> IF(!FP_INT_VERSION) [-x] cMul cSin
x cMul cSinh cNeg -> IF(!FP_INT_VERSION) [-x] cMul cSinh
x cMul cTan  cNeg -> IF(!FP_INT_VERSION) [-x] cMul cTan
x cMul cTanh cNeg -> IF(!FP_INT_VERSION) [-x] cMul cTanh

cAcosh cSinh -> IF(!FP_INT_VERSION) cSqr [Value_t(-1)] cAdd cSqrt
cAsinh cCosh -> IF(!FP_INT_VERSION) cSqr  [Value_t(1)] cAdd cSqrt
cSin cInv -> IF(!FP_INT_VERSION) cCsc
cCos cInv -> IF(!FP_INT_VERSION) cSec
cTan cInv -> IF(!FP_INT_VERSION) cCot
cCsc cInv -> IF(!FP_INT_VERSION) cSin
cSec cInv -> IF(!FP_INT_VERSION) cCos
cCot cInv -> IF(!FP_INT_VERSION) cTan

# Hardcoded optimizations that are too complex or
# impossible to convey using this rule file:
x cPow -> [DO_POWI]
A cMul -> [DO_MAYBE_SQR]
